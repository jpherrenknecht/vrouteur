<html>

<head>
    <title>Vrouteur </title>

    <meta name="Author" content="JP Herrenknecht">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />

    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@tmcw/togeojson"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>


    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/vrouteur.css') }}">
    <link rel="shortcut icon" href="{{ url_for('static', filename='img/favicon.ico') }}">

    <script type="text/javascript" src="{{ url_for('static', filename='js/vrouteur.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/leaflet.curve.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/Path.Drag.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/leaflet-arc.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/boatmarker.min.js') }}"></script>

    <script type="text/javascript">


        //************************************************************************************************
        // 74    Gestion du websocket
        // 110   Declaration des variables 
        // 217   Windy init
        // 255   reception update websocket  
        // 675   Fonctions d affichage         
        // 1159   Fonctions utilitaires 
        // 1779   Fonctions de gestion de localstorage 
        // 1526  Fonctions asynchrones de recuperation des infos sur serveur
        // 1936  Fonctions de validation de l input  et recuperation coordonneees 
        // 2926  Gestion des waypoints
        // 2359  Recherche des cartes VR
        // 2421  Gestion de l editeur de routes

        // 3785  Affichage de la flotte
        // 2818  Zones d exclusions perso
        // 3000  Gestion boite jaune
        // 4343  Exemples gestion personalinfos 
        // 3330  main Programme principal
        //     
        // 3526  Changement utilisateur 
        // 3670  Changement de course 
        // 3990  Utilisateur inconnu
        // 4100  Fonctions d affichage diverses
        // 5570  Listeners

        // 4965  Ouverure routage dans div au lieu de popup
        // 4156  Gestionnaires de map 
        // 3212  Lancement et mises a jour
        // 4319  Fin du script et de windyinit



        var origine = "{{origine}}"
        var sourceinfos = "{{source}}"
        // eslint-disable-next-line
        var posStart = {{ posStart | tojson }}

        if (sourceinfos == 'dash') {       
                isMe = posStart.isMe               
                if (isMe=='yes')   {console.log ('c est moi '+posStart.username)}
                if (isMe=='no') {console.log ('ce sont les informations pour '+posStart.username)}

            }



        var serveurdistant = "https://vrouteur.com";   //sur linux0
        var serveurlocal = "http://127.0.0.1:5000";   //sur linux1 et linux 3 

        if (origine == 'http://127.0.0.1:5000/') { var serveur = serveurlocal;document.title = "Vrouteur local"; }
        else { var serveur = serveurdistant }

        console.log('Serveur                 : ' + serveur)
        console.log('Origine de l ip         : ' + origine)
        console.log('Source des infos        : ' + sourceinfos)
        console.log('Username dans posStart : ' + posStart['username'])

        //****************************************************************************************************
        //*********  Gestion du websocket     ***********************************************************
        //****************************************************************************************************


        // function setStatusIndicator(connected) {
        //     const indicator = document.getElementById("status-indicator");
        //     indicator.style.backgroundColor = connected ? "green" : "red";
        // }

        const socket = io({
            reconnection: true,           // true par d√©faut
            reconnectionAttempts: Infinity,      //5,      // nombre max de tentatives
            reconnectionDelay: 1000,      // d√©lai entre les tentatives (ms)
            reconnectionDelayMax: 5000,   // d√©lai max (ms)
        });









        socket.on("registered", (data) => {
            if (data.status === 'ok') {
                console.log("Client enregistr√© en websocket avec l'id :", data.client_id);
                try {
                    let indicator = document.getElementById("status-indicator");
                    indicator.style.backgroundColor = "green"
                }
                catch { console.log('indicator pas defini') }
                // Test : demande une mise √† jour depuis le serveur
                socket.emit("request_test_update", { client_id: data.client_id });
            } else {
                console.error("Erreur d'enregistrement :", data.message);
            }
        });




        socket.on("reconnect_attempt", (attempt) => {
            console.log(`Tentative de reconnexion (${attempt})`);
        });

        socket.on("reconnect", () => {
            console.log("‚úÖ Reconnexion r√©ussie !");
        });

        socket.on("reconnect_failed", () => {
            console.log("‚ùå √âchec de reconnexion !");
        });

        socket.on("disconnect", (reason) => {
            try {
                let indicator = document.getElementById("status-indicator");
                indicator.style.backgroundColor = "red"
            }
            catch { console.log('indicator pas defini') }

            console.log("üö´ D√©connect√© :", reason);
            // setStatusIndicator(false)
        });


        async function registerClientId(user_id) {
            console.log("Enregistrement du client sur websocket  avec user_id :", user_id);
            socket.emit("register", { client_id: user_id });
        }


        //****************************************************************************************************
        //*********  Variables Globales            ***********************************************************
        //****************************************************************************************************


        var tabNameCourses = new Array();
        var coursecomplete = new Array();
        var trajet = new Array();
        var ari = new Array();
        var coursesUser = new Array();
        var tabLignesCheckPoints = new Array();
        var polylineCourse = new Array();
        var polylineCurve = new Array();
        var zonesExclusions = new Array();
        var tooltip = new Array();
        var tooltipprog = new Array();
        var waypoints = new Array();
        var newwaypoints = new Array();
        var nomsWaypoints = new Array();
        var ari = new Array();
        var arrayroutage = new Array();
        var tc = new Array();                                         // temps des isochrones   
        var tabtempsroutage = new Array();                                         // destine a remplacer tc
        var arraypolairesglobales = new Array();
        var arraytabvmg10 = new Array();
        var circleprog = new Array();
        var circleprog2 = new Array();     //Cercles pour le cheminement des wp
        var circleprog3 = new Array();     // Petit cercle central si changement de programmation 
        var circleWPVR = new Array();     // Cercles representant les WP
        var polyglobal2 = new Array();     // pour tracer les lignes de la programmation  
        var programmationsvrjaunes = new Array();
        var programmationsvr = new Array();
        var nomsZonesExclu = new Array();     // les 3 sont les memes
        var nomroutage = new Array();
        var routages = new Array();
        var polyglobal = new Array();     // destin√© a recevoir le routage avec les couleurs de voiles 
        var polyglobal2 = new Array();     // destin√© a recevoir le routage avec les couleurs de voiles 
        var teamnames = new Array();
        let exclusionsMap = new Map();


        var zoneNames = []; // Tableau pour stocker les noms des zones
        var listeZones = [];
        var listeBarrieres = []
        var nomsroutages = [];

        var tabSelected;

        let zonesPolygones = {}; // Stocker les polygones pour pouvoir les supprimer plus tard

        var typeVoiles = ['jib', 'Spi', 'Staysail', 'LightJib', 'Code0', 'HeavyGnk', 'LightGnk'];
        var typeVoilesShort = ['JI', 'SP', 'ST', 'LJ', 'C0', 'HG', 'LG'];
        var colors = ['red', 'lime', 'blue', 'orange', 'darkgreen', '#b00000', '#d77900'];
        var colorhex = ['#2F67FA', '#C62F3E', '#319B43', '#E4FB74', '#FFE852', '#52FCFF']

        // Localstorage 
        var username;
        var course;
        var ycoord;                       // Derniers coordonnees rentres
        var xcoord;
        var y0vr;                         // Derni√®re position VR 
        var x0vr;
        var t0vr;
        var t0;
        var y1;                           // derniers coordonn√©s de l 'arrivee 
        var x1;
        var dep;                          // valeur de depart

        var Source;
        var t0routage;                    // heure de depart du routage 
        var t1routage = 0;                    // heure de depart du routage
        var tolerancehvmg = 0;

        var user_id;
        var nbWP;

        var indiceCourse;
        var nbprogress = 0;                 // valeur de l avancement dans progressbar       
        var intervalid;                   // valeur de l intervalle dans progressbar  

        let nowJS = new Date()
        let nowMSec = nowJS.getTime()
        var decalageUTC = nowJS.getTimezoneOffset()
        var unixTimestamp;      // valeur du temps unix  
        var ecartTemps;            // Ecart entre la mise a jour et le temps actuel pour message sur position>10mn
        var eta;
        var dureeparcours;

        // valeurs extraites des tables 
        var boatinfos;
        var leginfos;
        var personalinfos;
        var personalInfosStr;
        var progsvr;
        var etatinitial;    // premiere prog correspondant a l etat courant  
        var couleurwp = 'yellow'
        var boatVisibility = 1
        var nomlocalstorage = 'memoiretrajets'
        var urlPolaires;
        // variable permettant de bloquer les mises a jour pendantle routage
        var bloque = 0;

        var cocheexclusions = false

        let popupPolaires
        let popupPara;
        let overlay = null; // Variable globale
        let boite = null; // Variable globale
        var windiv = document.getElementById("windy")
        const options = { key: 'ydO74Xuxv2WWOEShDpel1kaiae8zCnLO', verbose: true, lat: 46.1551, lon: -1.2297, zoom: 8 };             //Positionn√© sur La Rochelle par defaut 



        //****************************************************************************************************
        //*********  Declaration des Layers                 **************************************************
        //****************************************************************************************************


        var lgMarkers = new L.LayerGroup()
        var lgDashLines = new L.LayerGroup()
        var routageLayer = new L.LayerGroup()
        var boatMarkers = new L.LayerGroup()
        var fleetMarkers = new L.LayerGroup()
        var layerExclusions = new L.LayerGroup()
        var layerBarrieres = new L.LayerGroup()
        var WpCirclesLayer = new L.LayerGroup()
        var routageCircles = new L.LayerGroup()
        var isochronesLayer = new L.LayerGroup()
        var progsvrLayer = new L.LayerGroup()
        var progsvrLayerJaune = new L.LayerGroup()
        var circleBoatLayer = new L.LayerGroup()
        var cartesLayer = new L.LayerGroup()
        var lgMarkersVR = new L.LayerGroup()     //waypoints vr 
        var lgMarkersVR2 = new L.LayerGroup()     //waypoints vr 
        var grilleLayer = new L.LayerGroup()

        var circlew = new L.circle();
        var popup = L.popup();

        var gpx1LayerGroup = new L.layerGroup();  // groupe d√©di√© aux CSV
        var gpx2LayerGroup = new L.layerGroup();  // groupe d√©di√© aux CSV
        var csvLayerGroup = new L.layerGroup();  // groupe d√©di√© aux CSV






        let windyLayers = []; // stockage des couches Windy internes


        windyInit(options, windyAPI => {

            const { map, picker, utils, broadcast, store } = windyAPI;
            var windiv = document.getElementById("windy")

            map.setMaxZoom(22); // Augmente la limite globale de zoom

            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                minZoom: 1,
                maxZoom: 22,
                attribution: '¬© OpenStreetMap'
            });


            // Capturer les couches ajout√©es par Windy (souvent L.GridLayer avec une propri√©t√© .options.data)
            // map.eachLayer(layer => {
            //     if (layer.options && layer.options.data) {
            //         windyLayers.push(layer);
            //     }
            // });



            //       map.addLayer(osmLayer);



            map.eachLayer(layer => {
                if (layer.getTileUrl) {
                    windyLayers.push(layer);

                    // Sauvegarder l‚Äôoriginal
                    const originalGetTileUrl = layer.getTileUrl.bind(layer);

                    // Remplacer par une version filtr√©e
                    layer.getTileUrl = function (coords) {
                        const z = coords.z;
                        if (z > 20) {
                            return ''; // emp√™che toute requ√™te
                        }
                        return originalGetTileUrl(coords);
                    };
                }
            });









            map.on('zoomend', () => {
                const currentZoom = map.getZoom();
                console.log('currentZoom', currentZoom);

                if (currentZoom > 9) {
                    map.addLayer(osmLayer);
                } else {
                    map.removeLayer(osmLayer);
                }

                if (currentZoom > 20) {
                    // Retirer les couches Windy pour stopper les requ√™tes
                    windyLayers.forEach(l => {
                        if (map.hasLayer(l)) {
                            map.removeLayer(l);
                            console.log("Windy layer removed at zoom > 20");
                        }
                    });
                } else {
                    // R√©activer Windy si besoin
                    windyLayers.forEach(l => {
                        if (!map.hasLayer(l)) {
                            map.addLayer(l);
                            console.log("Windy layer re-added at zoom <= 20");
                        }
                    });
                }
            });























            // map.on('zoomend', () => {
            //     const currentZoom = map.getZoom();
            //     console.log('currentZoom ', currentZoom);

            //     if (currentZoom > 9) {
            //         map.addLayer(osmLayer);
            //     } 
            //     else {
            //         map.removeLayer(osmLayer);


            //         };

            // });














            L.control.scale({
                position: 'bottomright',
                imperial: false,
                metric: true
            }).addTo(map)




            socket.on("update", (data) => {

                response = data.message
                console.log('Message du serveur data.message ' + response)
                typereponse = response['Reception']

                if (typereponse) {
                    course2 = response['course']
                    console.log(typereponse)
                    console.log("Message re√ßu du serveur par le websocket :" + typereponse + "pour course " + course2 + " √†" + intlhmn.format(Date.now()));
                    console.log('*******************************************************')
                }


                if (typereponse == 'boatinfos') {
                    // console.log ('Traitement de  boatinfos')
                    // console.log('********************************************************')
                    if (course2 != course) {
                        console.log('Changement de course√† effectuer ')
                        changementcourse(username, course2)
                        course = course2
                    }
                    console.log('Update de boatinfos pour ' + username + ' course ' + course + ' bloque ' + bloque)
                    update(username, course, bloque)
                    console.log('boatinfos trait√©')
                    if (overlay) { overlay.remove(); }
                }


                if (typereponse == 'boatActions') {
                    console.log('\non traite boatActions\n*******************************')
                    console.log('test user_id' + user_id + ' username ' + username + ' course ' + course + ' t0routage ' + t0routage)
                    update(username, course, bloque)
                    chercheprogsvr(user_id, course, t0routage)
                    console.log('boatActions trait√©')
                    let boite = document.querySelector(".boite2");
                    let overlay = boite.querySelector(".boite-overlay");
                }



                if (typereponse == 'getfleet') {
                    console.log('\non traite getfleet pour changer de course \n*******************************')
                    afficheFlotte()
                    course2 = response['course']
                    console.log('test user_id' + user_id + ' course ' + course + ' t0routage ' + t0routage)
                    if (course2 != course)
                        changementcourse(username, course2)
                    course = course2
                }


            });








            async function update(username, course2, bloque) {
                if (bloque == 0) {

                    // on a besoin des donnees boatinfos
                    console.log('\nDemande de update le ' + intlhmn.format(Date.now()))
                    console.log('Course ' + course)
                    console.log('Course2 ' + course2)

                    if (course2 != course) {
                        console.log('changement de course declenche par boatinfos')
                        leginfos = chercheleginfos(course2)
                        changementcourse(username, course2)
                        course = course2

                    }

                    boatinfosdata = await chercheboatinfos(username, course2)
                    boatinfos = boatinfosdata.result
                    if (boatinfos != null) { afficheboatinfos(boatinfosdata) }
                    else { console.log("Ce bateau n'etant pas connu dans boatinfos , √ßa ne sert √† rien de faire un update ") }

                } //fin du bloquage si routage 
            } //fin de update  









            var texteboite1 = `
    <div class="titrevrouteur"  id="boite1" >  VRouteur     <span class="droite">  <a href="http://virtualregatta.com/fr/offshore-jeu/" target= "_blank">VR</a></span>
    <div name='routage'  >
    <table class='table3' id= 'table31'><tr>
    <td>  <input type='text' class='black11' id ='idusername' name='username' placeholder= 'Nom du bateau sur VR'  required size=16> </td>
    <td colspan=2> <span id='idselectcourse' name='selectcourse' class='black11' placeholder ='Choix de la Course'> 
    <select id='idcourse'> <option value='654.1'  selected >Vendee Globe </option></select>    </span>
      </td></tr>  
    </table>

    <table class='table3' id= 'table32' >
     <tr><td class='l20px' >De</td> <td  id='idselectdepart' ></td><td  rowspan='3' class='center' > A</td> <td rowspan='3' id='idselectarrivee'  > </td></tr>

   
   

    </table>
    </div>
    <div id="coordinateInput">
    <!--<label for="inputCoordinates">coordonn√©es (DMS) :</label>-->
    <input type="text" id="inputCoordinates" placeholder="Ou Coordonnees du Dash avec Ctrl+C Ctrl+V" size="35">
    </div>
    <div id="coordinateDepInput">
            <!-- Latitude -->
            <span id="latitude">
               <!-- <label>Latitude:</label>-->
                <input class="classinput" type="number" id="deplatDeg" min="0" max="90" step="1" value="0">¬∞
                <input class="classinput2" type="number" id="deplatMin" min="0" max="60" step="1" value="0"> 
                <input class="classinput2" type="number" id="deplatSec" min="0" max="60" step="1" value="0">
                <select id="deplatDir" class="classinput5" >
                    <option value="N" selected>N</option>
                    <option value="S">S</option>
                </select>
            </span>
        
        <!-- Longitude -->
            --<span id="longitude">
                <!--<label>Longitude:</label>-->
                <input class="classinput" type="number" id="deplngDeg" min="0" max="180" step="1" value="0">¬∞
                <input class="classinput2" type="number" id="deplngMin" min="0" max="60" step="1" value="0"> 
                <input class="classinput2" type="number" id="deplngSec" min="0" max="60" step="1" value="0">
                <select id="deplngDir" class="classinput5" >
                    <option value="E" selected>E</option>
                    <option value="W">W</option>
                </select>
            </span>
    </div>
    <div><label>Position du dernier WP s√©lectionn√© : </label> <label id='iddernierwp'>(Arriv√©e)</label> </div>
          
    <div id="coordinateAriInput">
            <!-- Latitude -->
            <span id="latitude">
               <!-- <label>Latitude:</label>-->
                <input class="classinput" type="number" id="arilatDeg" min="0" max="90" step="1" value="0">¬∞
                <input class="classinput2" type="number" id="arilatMin" min="0" max="60" step="1" value="0"> 
                <input class="classinput2" type="number" id="arilatSec" min="0" max="60" step="1" value="0">
                <select id="arilatDir" class="classinput5" >
                    <option value="N" selected>N</option>
                    <option value="S">S</option>
                </select>
            </span>
        
        <!-- Longitude -->
            --<span id="longitude">
                <!--<label>Longitude:</label>-->
                <input class="classinput" type="number" id="arilngDeg" min="0" max="180" step="1" value="0">¬∞
                <input class="classinput2" type="number" id="arilngMin" min="0" max="60" step="1" value="0"> 
                <input class="classinput2" type="number" id="arilngSec" min="0" max="60" step="1" value="0">
                <select id="arilngDir" class="classinput5" >
                    <option value="E" selected>E</option>
                    <option value="W">W</option>
                </select>
            </span>
    </div>
   
    <span class='heuredepart'><label>Heure Depart :</label>
    <input type="datetime-local" id="datetime"   class= "datetime-compact" />
     </span>
    <span> Hvmg + <input class="classinput2" type="number" id="tolerancehvmg" min="0" max="10" step="1" value="0">¬∞</span><br>

    <div   id ='dategrib' class='dategrib' > Grib :  </div><br>
    <div align='center'>
    <button  id='lancerRoutage' class='blackwhite11' value='Lancer le routage' > Lancer le Routage </button>
  
   
    <progress value='0' min='0' max='100' id ='progress'></progress>
   <span id='eta' class='eta'></span>    <span id='dureeeta'></span><span  id='detailroute2'></span><br>

    Isos  <input type='checkbox' id='showisochrones' name='showisochrones'  />   
    Boat  <input type='checkbox' id='showboat' name='showboat' checked  />
    Route <input type='checkbox' id='showprogsvr' name='showprogsvr'  checked    />
      
    Flotte <input type='checkbox' id='showflotte' name='showflotte'  />   
    Marques   <input type='checkbox' id='showmarques' name='showmarques' checked  />
   
    </div>`


            var texteboite2 = `    <div  >
        <span class='col0'> Donn√©es VR du :</span><span   class ='col1'  id='dateposvr'  > </span> <span class= 'col2' id='usernamevr'>     </span> <span class='col3'   >Clt : </span><span class='col4' id='rankvr'  ></span>
           
        <div class='position'>
            <br/>
            <em> Lat : </em><span class='sp11' id='y0vr'  ></span> 
            <em> Lng : </em><span class='sp12' id ='x0vr'></span>
    </div> 
    <table class='table50' id= 'table21'>
        <tr>
           <td>Speed</td>    <td id='speedvr'></td>    <td>Twsvr </td> <td id='twsvr'   ></td>   <td> Twdvr </td>    <td id='twdvr'¬† ></td> 
        </tr><tr>
        <td>Cap </td><td id='headingvr' ></td><td>Twscalc </td>    <td id='twscalc' ></td>     <td> Twdcalc </td>  <td id='twdcalc'></td>
        </tr><tr>
         <td> Sail </td>  <td id='sailvr'></td>        <td >Twavr </td><td id='twavr' class='red'></td>                             <td>Stamina</td>   <td  id='staminavr'></td></tr>
        <tr><td colspan=2> Voiles auto</td ><td><input type='checkbox' id='voilesautovr' name='voilesautovr'  checked    /></td>
        <td colspan=2> Twa auto</td ><td><input type='checkbox' id='twaauto' name='twaauto'  checked    /></td></tr>
        </table>   
         
        <div id="status-indicator" style="width: 10px; height: 10px; background-color: red; border-radius: 50%;"></div>   
    </div>`




            var texteboite22 = " "
                + "<div class='caravoiles' id='caravoiles' >"
                + "<table>"
                + "<tr><td>Tws</td><td><input class='classinput50' type='number' min='0' max='35'   step='.1' id ='twsvmg'   size='8'><td>Vmg</td> <td id='vmgmin2' class='pink' ></td>  <td id='vmgmax2' class='pink'>  </td><td id='vmax2' class='pink'></td></tr>"
                + "</table>"
                + "<table id='tabrecou'>"
                + "</table>"
                + "</div>"



            y0 = 0
            x0 = 0
            var twsjp = 50;        // voir a supprimer
            var twdjp = 100;

            var texteboite3 = " "
                + "<div class='cap'>"
                + "<em>HDG : </em><span class='spred50' id='hdg'>--</span>"
                + "<input type='checkbox' id='cochehdg' name='cochehdg' checked  />"
                + "<span class='col1'>       </span>  "
                + "<em>  TWA : </em><span class='green50' id='twa'>--</span>"
                + "<input type='checkbox' id='cochetwa' name='cochetwa'  checked    />"

                + "</div>"
                + "<div class='position'>"
                + "<br/>"
                + "<em> Lat : </em><span class='sp11' id='latitudevent'  >" + pos_dec_mn_lat(y0) + '(' + y0.toFixed(4) + ")</span>"
                + "<em> Lng : </em><span class='sp12' id ='longitudevent'>" + pos_dec_mn_lng(x0) + '(' + x0.toFixed(4) + ")</span>"
                + "</div> "
            // +"<br/> "
            // +"<div class='vent'><em> "
            //     +"<span id= 'ecarth' class='sp15'> "
            //         +"H + <input class='classinput50' type='number' min='0' max='72'    step='1' id ='mnDecalageMeteo'  value='0' size='7'> h </span></em>" 
            //         +" <span id= 'hprev' class='sp15'>"+hmns.format(tempscourant)+"</span>"            
            //         +"<em>   TWS   </em><span class='sp11purple' id='twscurseur'>"+twsjp.toFixed(2)+"</span>"
            //         +"<em>   TWD   </em><span class='sp12green' id='twdcurseur'>"+twdjp.toFixed(0)+"</span>"
            //             +"<br/> "
            //     +"</div>";
            course = '654.1'
            username = 'Takron-BSP'

            var texteboite4 =
                `<div class='liens' >
              
       <button id="btnDivers" class="blackwhite11">Calculettes</button>       
       <button onclick='EditeurExclusions()' class="blackwhite11">Exclusions</button>
       <button onclick='EditeurBarrieres()' class="blackwhite11">Barrieres</button>
       <button id="btnPolaires" class="blackwhite11">Polaires</button>
       <button onclick='EditeurRoutes()' class="blackwhite11">Routes</button>

       <input type="file" id="gpx-input" accept=".gpx" style="margin: 10px;" />
       <label for="gpx-input" class="chargergpx">üìÇ Charger GPX1</label>

        <input type="file" id="gpx-input2" accept=".gpx" style="margin: 10px;" />
        <label for="gpx-input2" class="chargergpx">üìÇ Charger GPX2</label>

        <input type="file" id="csv-input3" accept=".csv" style="margin: 10px;" />
        <label for="csv-input3" class="chargergpx">üìÇ CSV Dorado </label>
       <div class='checkbox'>
        Gpx1  <input type='checkbox' id='showgpx1' name='showgpx1' checked />   
        Gpx2  <input type='checkbox' id='showgpx2' name='showgpx2'  checked />   
        Csv Dorado   <input type='checkbox' id='showcsv'  name='showcsv'  checked />   
      </div>
        

       </div>`;
       

        
       
       
       
       
       var texteboite44 =
                `<div class='progsvr' >
         <span class= 'col150' > Programmations VR </span>       
        <button  id='rafraichir' class='blackwhite11' value='0' > Rafraichir </button>
       
        <button  id='dupliquerprogsvr' class='blackwhite11' value='0' > Dupliquer  </button>
        <div id='idprogrammationsvr' class='idprogrammationsvr' ></div>
       </div>`;



            var texteboitejaune = "<div id='boitejaune' ></div>"
            //+ intlhmn.format(t0*1000)+textsimultwa(donnees[0][0],donnees[0][1],donnees[0][2],donnees[0][3],donnees[0][4])+



            var texteEditeurWP =
                `<div id="waypointEditor" class="waypointeditor">
        <span class="close-button" onclick="fermerEditeurWaypoint()">√ó</span>       
        <h3>Modifier le Waypoint</h3>
        <p>Nom: <span id="wpName"></span></p>
        <p>Latitude: <span id="wpLat"></span></p>
        <p>Longitude: <span id="wpLon"></span></p>
        <span> Rayon: <input type="number" id="wpRadius" step="0.1" style="width: 60px;"> NM &nbsp;</span>
        Couleur: <input type="color" id="wpColor" value="#FFFF00"></input><br>
        <button id="saveWaypoint">Sauvegarder le WP</button>
        <button id="deleteWaypoint">Supprimer le WP</button>
    </div>`;


            var texteEditeurExclusions = ""
                + '<div id="exEditor" class = "exEditor" >'
                + '  <span class="close-button" onclick="fermerEditeurEx()">√ó</span>'
                + `<h3>Zones d\'exclusions personnalis√©es</h3>`
                + `  <label for="dynamicSelect">Zones existantes :</label>
            <select id="dynamicSelect"> </select>`

                + `<button onclick="fermerEx()"  id="fermerEx">Supprimer la zone</button>`
                + `<div id="addSection">`
                + `<input type="text" size=10 id="nomNewZone" placeholder="Nouvelle zone" title="Zone √† cr√©er">`
                + `<button onclick="startDrawing()"  id="startDrawing">Demarrer</button>`
                + `<button   onclick="finishDrawing()" id="finishDrawing"  >Sauver</button>`
                + `<button   onclick="deleteDrawing()" id="deleteDrawing"  >Supprimer</button>`
                + `</div>`;

            var texteEditeurBarrieres = ""
                + '<div id="baEditor" class = "baEditor" >'
                + '  <span class="close-button" onclick="fermerEditeurBa()">√ó</span>'
                + `<h3>Barri√®res </h3>`
                + `  <label for="BarrieresSelect">Barrieres existantes :</label>
            <select id="BarrieresSelect"> </select>`
                + `<button onclick="fermerBa()"  id="fermerBa">Supprimer la barriere</button>`
                + `<div id="addSectionba">`

                + `<br><label for="Nouvellebarriere">Nouvelle Barri√®re</label><br>`
                + `<input type="text" size=10 id="nomNewBarriere" placeholder="Nom Barriere" title="Nouvelle barriere">`
                + `<button onclick="startDrawingBa()"  id="startDrawingBa">Demarrer</button>`

                + `<button   onclick="finishDrawingBa()" id="finishDrawingBa"  >Sauver</button>`
                + `<button   onclick="deleteDrawingBa()" id="deleteDrawingBa"  >Supprimer</button>`
                + `</div>`;




            var texteEditeurRoutes =
                `<div id="RoutesEditor" class = "RoutesEditor" >
         <span class="close-button" onclick="fermerEditeurRoutes()">√ó</span>  
        <h3>Editeur de Routes</h3>
        <label> Route  √† enregistrer </label>
        <input type="text" size=15 id="nomRoutage" placeholder="Nom  du Routage"    value ="${genererNomRoutage()}" title="Zone √† cr√©er">
        <button onclick="sauveroute()"  id="sauveroute">Sauvegarder la route</button>
        <br><br>
        <div id="tableroutages"></div>
        </table>    
        </div>`;





            function initBoites()                                       //necessaire
            {
                // on va rajouter des div  a windy    
                const newElt1 = document.createElement("div");
                newElt1.setAttribute("id", "boite1")
                windiv.appendChild(newElt1);
                newElt1.classList.add("boite1");
                newElt1.innerHTML = texteboite1

                const newElt2 = document.createElement("div");             // c'est la boite des infos vr
                newElt2.setAttribute("id", "boite2")
                windiv.appendChild(newElt2);
                newElt2.classList.add("boite2");
                newElt2.innerHTML = texteboite2

                const newElt22 = document.createElement("div");            // c'est la boite des recouvrements
                newElt22.setAttribute("id", "boite22")
                windiv.appendChild(newElt22);
                newElt22.classList.add("boite22");
                newElt22.innerHTML = texteboite22


                const newElt23 = document.createElement("div");             // c'est la boite des recouvrements
                newElt23.setAttribute("id", "popup22")
                windiv.appendChild(newElt23);
                newElt23.innerHTML = texteEditeurWP

                const newElt3 = document.createElement("div");              // c'est la boite qui suit le curseur et donne la position et le vent 
                newElt3.setAttribute("id", "boite3")
                windiv.appendChild(newElt3);
                newElt3.classList.add("boite3");
                newElt3.innerHTML = texteboite3

                const newElt4 = document.createElement("div");              // c'est la boite des liens parametres cartes polaires 
                newElt4.setAttribute("id", "boite4")
                windiv.appendChild(newElt4);
                newElt4.classList.add("boite4");
                newElt4.innerHTML = texteboite4


                const newElt44 = document.createElement("div");              // c'est la boite des liens parametres cartes polaires 
                newElt44.setAttribute("id", "boite44")
                windiv.appendChild(newElt44);
                newElt44.classList.add("boite44");
                newElt44.innerHTML = texteboite44

                const newElt5 = document.createElement("div");      // c est la boite jaune pour simulation 
                windiv.appendChild(newElt5);
                newElt5.id = "boitejaune";                          // Ajout de l'id
                newElt5.classList.add("boite5");                    // ajout de la classe


                const newElt24 = document.createElement("div");             // c'est la boite des recouvrements
                newElt24.setAttribute("id", "popup24")
                windiv.appendChild(newElt24);
                newElt24.innerHTML = texteEditeurExclusions


                const newElt25 = document.createElement("div");             // c'est la boite des recouvrements
                newElt25.setAttribute("id", "popup25")
                windiv.appendChild(newElt25);
                newElt25.innerHTML = texteEditeurRoutes


                const newElt26 = document.createElement("div");             // c'est la boite des recouvrements
                newElt26.setAttribute("id", "popup26")
                windiv.appendChild(newElt26);
                newElt26.innerHTML = texteEditeurBarrieres


                // const newElt6 = document.createElement("div");     // c est la boite rouge pour simulation
                // elt.appendChild(newElt6);
                // newElt6.classList.add("boite6"); 
                // newElt6.innerHTML= "<div id='achoix2' name='achoix2' > test3  </div>" 
                // captab=100 
                // donnees2= new Array([0,'cap',amure,Math.abs(Math.round(captab,0)),60])     //initialisation de la deuxieme boite de simulation
                // texte2 ="<div id='achoix2' name='achoix2'>"+ intlhmn.format(t0*1000)+textsimultwa2(donnees2[0][0],donnees2[0][1],donnees2[0][2],donnees2[0][3],donnees2[0][4])+"</div>"        
                // document.getElementById('achoix2').innerHTML=texte2



                // const newElt7 = document.createElement("div");     // c est la boite cach√©e pour ajout de Wp
                // windiv.appendChild(newElt7);
                // //newElt7.classList.add("popup2"); 
                // newElt7.innerHTML= textepopup
                // var closewp=document.getElementById('closewp') 
                // closewp.addEventListener("click", function (evt){
                //     var popup2        = document.getElementById('popup2');
                //     popup2.style.display = 'none';


                //         })

                var usernameInput = document.getElementById('idusername');

            }
            initBoites()








            //****************************************************************************************************
            //*********  Fonctions d affichage         ***********************************************************
            //****************************************************************************************************


            async function chercheboatinfos(username, course) {
                // recupere le resultat qui vient directement du serveur VR
                console.log(' Dans rechercheboatinfos user_id' + user_id)
                if (user_id) { registerClientId(user_id); }     //  on cherche a se reconnecter si jamais la connection a ete perdue 


                const url = serveur + "/rechercheboatinfos?username=" + username + "&user_id=" + user_id + "&course=" + course
                let response = await fetch(url);
                try {
                    if (!response.ok) { throw new Error('Probl√®me avec cherche Boatinfos ' + response.statusText); }
                    let data = await response.json();
                    boatinfos = data.result
                    tig = data.tig
                    indicemajgrib = data.indicemajgrib
                    console.log('ligne 1174  tig ' + intlhmn.format(tig * 1000))
                    console.log('Indice ' + indicemajgrib)
                    return data
                }
                catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de boatinfos :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }



            async function chercheTeamNames(teamname) {
                // recupere le resultat qui vient directement du serveur VR
                console.log('On est dans recherche team names')

                const url = serveur + "/rechercheteam?teamname=" + teamname
                let response = await fetch(url);

                if (!response.ok) { throw new Error('Probl√®me avec cherche teamnames ' + response.statusText); }
                let data = await response.json();
                teamnames = data.result         //teamnames est deja un tableau 

                // Test 
                if (teamnames.includes("Takron-BSP")) {
                    console.log(" Liste des membres de la team de Takron r√©cup√©r√©e !");

                }

                //                 }
                // catch (error) {
                //     console.error("Erreur lors de la r√©cup√©ration de boatinfos :", error);
                //     throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                // }
            }






            async function afficheboatinfos(boatinfosdata)  // affiche les particularites de la course
            {
                console.log(' on est dans afficheboatinfos ')
                boatinfos = boatinfosdata.result
                console.log('boatinfos √† ' + intlhmn.format(Date.now()) + ' \n' + boatinfos)

                indicemajgrib = boatinfosdata.indicemajgrib
                tig = boatinfosdata.tig
                boatinfos = JSON.parse(boatinfos)
                boatinfosbs = boatinfos['bs']
                try { boatinfosBA = boatinfos['ba'] }

                catch { boatinfosBA = [] }
                //console.log (' ligne 3468   boatinfosBA \n  '+ JSON.stringify(boatinfosBA ))

                typebateau = boatinfosbs['boat']['name']                    //ok si course pas demarree              
                username = boatinfosbs['displayName']                     //ok si course pas demarree   
                race = boatinfosbs['_id']['race_id']                  //ok si course pas demarree  
                leg = boatinfosbs['_id']['leg_num']                 //ok si course pas demarree   
                course = race + '.' + leg

                user_id = boatinfosbs['_id']['user_id']
                polar_id = boatinfosbs['boat']['polar_id']
                heading = boatinfosbs['heading']
                y0vr = boatinfosbs['pos']['lat']
                x0vr = boatinfosbs['pos']['lon']
                sail = boatinfosbs['sail']
                speed = boatinfosbs['speed']
                legStartDate = boatinfosbs['legStartDate']




                if (boatinfosbs['lastCalcDate']) { lastCalcDate = boatinfosbs['lastCalcDate'] } else { lastCalcDate = legStartDate }
                if (boatinfosbs['twa']) { twavr = boatinfosbs['twa'] } else { twavr = 40 }
                if (boatinfosbs['tws']) { twsvr = boatinfosbs['tws'] } else { twsvr = 10 }
                if (boatinfosbs['twd']) { twdvr = boatinfosbs['twd'] } else { twdvr = 0 }
                if (boatinfosbs['stamina']) { stamina = boatinfosbs['stamina'] } else { stamina = 100 }
                if (boatinfosbs['state']) { state = boatinfosbs['state'] }
                if (boatinfosbs['twaAuto']) { twaAuto = boatinfosbs['twaAuto'] } else { twaAuto = twavr }
                if (boatinfosbs['stamina']) { stamina = boatinfosbs['stamina'] } else { stamina = 100 }
                if (boatinfosbs['rank']) { rankvr = boatinfosbs['rank'] } else { rankvr = 0 }
                if (boatinfosbs['tsEndOfAutoSail']) { tsEndOfAutoSail = boatinfosbs['tsEndOfAutoSail'] } else { tsEndOfAutoSail = lastCalcDate }
                if (boatinfosbs['tsEndOfSailChange']) { tsEndOfSailChange = boatinfosbs['tsEndOfSailChange'] }
                if (boatinfosbs['tsEndOfGybe']) { tsEndofGybe = boatinfosbs['tsEndOfGybe'] }
                if (boatinfosbs['tsEndOfTack']) { tsEndofTack = boatinfosbs['tsEndOfTack'] }
                if (boatinfosbs['tsLastAction']) { tsLastAction = boatinfosbs['tsLastAction'] }
                if (boatinfosbs['gateGroupCounters']) { gateGroupCounters = boatinfosbs['gateGroupCounters'] }
                var autosail = sail > 10 ? true : false
                var nowJS = new Date()
                var nowMSec = nowJS.getTime()
                ecartTemps = (nowMSec - lastCalcDate) / 1000



                try { boatinfosBA = boatinfos['ba'] }

                catch { boatinfosBA = [] }
                //console.log (' ligne 3468   boatinfosBA \n  '+ JSON.stringify(boatinfosBA ))

                //Variables qui existent toujours 
                typebateau = boatinfosbs['boat']['name']                    //ok si course pas demarree              
                username = boatinfosbs['displayName']                     //ok si course pas demarree   
                race = boatinfosbs['_id']['race_id']                  //ok si course pas demarree  
                leg = boatinfosbs['_id']['leg_num']                 //ok si course pas demarree   
                user_id = boatinfosbs['_id']['user_id']
                polar_id = boatinfosbs['boat']['polar_id']
                heading = boatinfosbs['heading']
                y0vr = boatinfosbs['pos']['lat']
                x0vr = boatinfosbs['pos']['lon']
                sail = boatinfosbs['sail']
                speed = boatinfosbs['speed']
                legStartDate = boatinfosbs['legStartDate']


                // Variables qui n existent pas toujours 
                if (boatinfosbs['lastCalcDate']) { lastCalcDate = boatinfosbs['lastCalcDate'] } else { lastCalcDate = legStartDate }
                if (boatinfosbs['twa']) { twavr = boatinfosbs['twa'] } else { twavr = 40 }
                if (boatinfosbs['tws']) { twsvr = boatinfosbs['tws'] } else { twsvr = 10 }
                if (boatinfosbs['twd']) { twdvr = boatinfosbs['twd'] } else { twdvr = 0 }
                if (boatinfosbs['stamina']) { stamina = boatinfosbs['stamina'] } else { stamina = 100 }
                if (boatinfosbs['state']) { state = boatinfosbs['state'] }
                if (boatinfosbs['twaAuto']) { twaAuto = boatinfosbs['twaAuto'] } else { twaAuto = twavr }
                if (boatinfosbs['stamina']) { stamina = boatinfosbs['stamina'] } else { stamina = 100 }
                if (boatinfosbs['rank']) { rankvr = boatinfosbs['rank'] } else { rankvr = 0 }
                if (boatinfosbs['tsEndOfAutoSail']) { tsEndOfAutoSail = boatinfosbs['tsEndOfAutoSail'] } else { tsEndOfAutoSail = lastCalcDate }
                if (boatinfosbs['tsEndOfSailChange']) { tsEndOfSailChange = boatinfosbs['tsEndOfSailChange'] }
                if (boatinfosbs['tsEndOfGybe']) { tsEndofGybe = boatinfosbs['tsEndOfGybe'] }
                if (boatinfosbs['tsEndOfTack']) { tsEndofTack = boatinfosbs['tsEndOfTack'] }
                if (boatinfosbs['tsLastAction']) { tsLastAction = boatinfosbs['tsLastAction'] }
                if (boatinfosbs['gateGroupCounters']) { gateGroupCounters = boatinfosbs['gateGroupCounters'] }


                var autosail = sail > 10 ? true : false
                var nowJS = new Date()
                var nowMSec = nowJS.getTime()
                ecartTemps = (nowMSec - lastCalcDate) / 1000


                // Affichage de l heure de depart 

                if (state == 'waiting') {
                    console.log('boatinfos course en attente' + JSON.stringify(boatinfosbs))
                    if (sail == 10) { sail = 11 }


                    // la voile est egale a 10 pour vr ce qui pose probleme 

                    // cas du record 
                    if (boatinfosbs['record']) {
                        console.log('On est sur une course record')
                        document.getElementById('iddepart').value = 2   //select depart sur depart heure manuelle   
                        t0 = nowMSec
                    }



                    else { //on est en attente mais on connait l heure de depart c est lindice 2 dans tabNameCourses 
                        console.log('Waiting n est pas precise mais l\'heure est anterieure a l heure de depart')
                        console.log('heure par boatinfos' + intlhmn.format(legStartDate))
                        // Cas du depart ulterieurement a l heure actuelle 
                        const nowUnix = Math.floor(Date.now()); // Timestamp Unix en M secondes    
                        //if (legStartDate> nowUnix) 
                        t0 = legStartDate / 1000
                        let dateFormattee = convertirUnixEnDatetimeLocal(legStartDate)
                        document.getElementById('datetime').value = dateFormattee
                        document.getElementById('iddepart').value = 1   //select depart sur depart heure auto
                    }
                }


                else {   // on est pas waiting=, donc on est en course ou inconnu (mais a ce moment la pas de boatinfos )
                    t0 = Math.ceil(lastCalcDate / 1000 / 60) * 60
                    var dateFormattee = convertirUnixEnDatetimeLocal(t0 * 1000)
                    document.getElementById('datetime').value = dateFormattee
                    document.getElementById('iddepart').value = 0   //select depart sur depart heure auto      
                    console.log('heure position vrt ' + hmns.format(t0 * 1000))
                }
                // fin de l affichage de l heure de depart 

                affichecoordsdep(y0vr, x0vr)                   // Les coordonnnees du depart sont celle de boatinfos  dans tous les cas


                // Remplissage de la boite 2 avec les donnees VR
                document.getElementById('dateposvr').innerHTML = intlhmn.format(lastCalcDate)
                document.getElementById('usernamevr').innerHTML = username
                document.getElementById('y0vr').innerHTML = pos_dec_mn_lat(y0vr) + '(' + y0vr.toFixed(4) + ") "
                document.getElementById('x0vr').innerHTML = pos_dec_mn_lng(x0vr) + '(' + x0vr.toFixed(4) + ") "
                document.getElementById('twsvr').innerHTML = twsvr.toFixed(2)
                document.getElementById('twdvr').innerHTML = twdvr.toFixed(2)
                document.getElementById('twavr').innerHTML = twavr.toFixed(2)
                document.getElementById('rankvr').innerHTML = rankvr
                document.getElementById('speedvr').innerHTML = speed.toFixed(2)
                document.getElementById('sailvr').innerHTML = typeVoiles[(sail % 10) ]
                document.getElementById('headingvr').innerHTML = heading.toFixed(2)
                document.getElementById('staminavr').innerHTML = stamina.toFixed(2)
                //document.getElementById('twscalc').innerHTML    = twscalc.toFixed(2)
                //document.getElementById('twdcalc').innerHTML    = twdcalc.toFixed(2)
                document.getElementById('twsvmg').value = twsvr.toFixed(2)

                if (sail >= 10) { document.getElementById('voilesautovr').checked = true }
                else { document.getElementById('voilesautovr').checked = false }



                if (twaAuto == twavr) { document.getElementById('twaauto').checked = true }
                else { document.getElementById('twaauto').checked = false }

                //console.log('twaAuto ' + twaAuto + 'twa ' + twavr)



                //document.getElementById('lienpolaires').innerHTML= "<a href=javascript:popupbasique('http://blacksailingpolars.vrzen.org/?race_id="+course+"&tws="+twsvr+"&twa="+Math.abs(twavr)+"&stam="+stamina+"&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile="+sail%10+"')>Polaires </a></span>"

                urlPolaires = `http://blacksailingpolars.vrzen.org/?race_id=${course}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail % 10}`


                document.getElementById('dategrib').innerHTML = 'Grib du ' + intldhmn.format(tig * 1000 + decalageUTC * 60000) + ' + ' + indicemajgrib * 3 + 'h'
                document.getElementById('voilesautovr').checked = autosail

                //Positionnement du bateau    
                // t0=lastCalcDate/1000
                //console.log(' ligne 3582 '+lastCalcDate/1000)
                // afficheBoat(y0vr, x0vr, t0, twsvr, twdvr, heading, username)
                afficheBoat2(y0vr, x0vr, t0, twsvr, twdvr, heading, twavr, speed, sail, username, 'blue')

                //map.panTo([y0vr,x0vr])     La positionnement se fait a chaque update ce qui est genant 
                //document.getElementById('lienpolaires').innerHTML= "<a href=javascript:popupbasique('http://blacksailingpolars.vrzen.org/?race_id="+course+"&tws="+twsvr+"&twa="+Math.abs(twavr)+"&stam="+stamina+"&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile="+sail%10+"')>Polaires </a></span>"
                // urlPolaires=`http://blacksailingpolars.vrzen.org/?race_id=${course}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail%10}`

                // On va chercher les valeurs pour les voiles et le vent 

                // on remet a jour le trajet avec les dernieres donnees boatinfos
                trajet = [username, course, y0vr, x0vr, y0vr, x0vr, t0vr, y1, x1, -1, user_id, ari, waypoints, 'maj par main']
                updateTrajet(username, course, trajet)

                document.getElementById('speedvr').innerHTML = speed.toFixed(2)
                document.getElementById('sailvr').innerHTML = typeVoiles[(sail % 10) ]
                document.getElementById('headingvr').innerHTML = heading.toFixed(2)
                document.getElementById('staminavr').innerHTML = stamina.toFixed(2)
                //document.getElementById('twscalc').innerHTML    = twscalc.toFixed(2)
                //document.getElementById('twdcalc').innerHTML    = twdcalc.toFixed(2)
                document.getElementById('twsvmg').value = twsvr.toFixed(2)

                if (sail >= 10) { document.getElementById('voilesautovr').checked = true }
                else { document.getElementById('voilesautovr').checked = false }



                if (twaAuto == twavr) { document.getElementById('twaauto').checked = true }
                else { document.getElementById('twaauto').checked = false }




                //document.getElementById('lienpolaires').innerHTML= "<a href=javascript:popupbasique('http://blacksailingpolars.vrzen.org/?race_id="+course+"&tws="+twsvr+"&twa="+Math.abs(twavr)+"&stam="+stamina+"&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile="+sail%10+"')>Polaires </a></span>"

                urlPolaires = `http://blacksailingpolars.vrzen.org/?race_id=${course}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail % 10}`


                document.getElementById('dategrib').innerHTML = 'Grib du ' + intldhmn.format(tig * 1000 + decalageUTC * 60000) + ' + ' + indicemajgrib * 3 + 'h'
                document.getElementById('voilesautovr').checked = autosail

                //Positionnement du bateau    
                // t0=lastCalcDate/1000
                //console.log(' ligne 3582 '+lastCalcDate/1000)
                //afficheBoat(y0vr, x0vr, t0, twsvr, twdvr, heading, username)
                afficheBoat2(y0vr, x0vr, t0, twsvr, twdvr, heading, twavr, speed, sail, username, 'blue')


                //map.panTo([y0vr,x0vr])     La positionnement se fait a chaque update ce qui est genant 
                //document.getElementById('lienpolaires').innerHTML= "<a href=javascript:popupbasique('http://blacksailingpolars.vrzen.org/?race_id="+course+"&tws="+twsvr+"&twa="+Math.abs(twavr)+"&stam="+stamina+"&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile="+sail%10+"')>Polaires </a></span>"
                // urlPolaires=`http://blacksailingpolars.vrzen.org/?race_id=${course}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail%10}`

                // On va chercher les valeurs pour les voiles et le vent 

                // on remet a jour le trajet avec les dernieres donnees boatinfos
                trajet = [username, course, y0vr, x0vr, y0vr, x0vr, t0vr, y1, x1, -1, user_id, ari, waypoints, 'maj par main']
                updateTrajet(username, course, trajet)



                //console.log ('ligne2743 '+intlhmn.format(t0vr*1000))
                t0routage = Math.ceil(t0 / 60) * 60;
                try { await chercheprogsvr(user_id, course, t0routage) }  // se charge de l affichage
                catch { console.log('Probleme dans la recuperation de progsvr') }

                //console.log ('ligne 3599 '+y0vr+'  '+x0vr+ '  '+t0+' '+twsvr+'  '+twavr+' '+polar_id)
                resvoiles = await cherchevoiles(y0vr, x0vr, t0, twsvr, twavr, polar_id)
                //deltat= nowUnix-LastCalcDate/1000
                //console.log ('ecartTemps   '+ecartTemps ) 
                //verifierDeltat(ecartTemps) 


            }


            function affichecoordsdep(latDecimal, lngDecimal) {
                const { latDeg, latMin, latSec, latDir, lngDeg, lngMin, lngSec, lngDir } = fromDecimal(latDecimal, lngDecimal)
                //console.log(' test '+latDeg+' '+ latMin +' '+latSec+' '+ latDir+' '+ lngDeg+' '+ lngMin +' '+lngSec +' '+lngDir)
                document.getElementById("deplatDeg").value = latDeg;
                document.getElementById("deplatMin").value = latMin;
                document.getElementById("deplatSec").value = latSec;
                document.getElementById("deplatDir").value = latDir;
                document.getElementById("deplngDeg").value = lngDeg;
                document.getElementById("deplngMin").value = lngMin;
                document.getElementById("deplngSec").value = lngSec;
                document.getElementById("deplngDir").value = lngDir;
            }


            function affichecoordsari(latDecimal, lngDecimal) {
                const { latDeg, latMin, latSec, latDir, lngDeg, lngMin, lngSec, lngDir } = fromDecimal(latDecimal, lngDecimal)
                //console.log(' test '+latDeg+' '+ latMin +' '+latSec+' '+ latDir+' '+ lngDeg+' '+ lngMin +' '+lngSec +' '+lngDir)isochrones
                document.getElementById("arilatDeg").value = latDeg;
                document.getElementById("arilatMin").value = latMin;
                document.getElementById("arilatSec").value = latSec;
                document.getElementById("arilatDir").value = latDir;
                document.getElementById("arilngDeg").value = lngDeg;
                document.getElementById("arilngMin").value = lngMin;
                document.getElementById("arilngSec").value = lngSec;
                document.getElementById("arilngDir").value = lngDir;

            }



            function afficheBoat2(yb, xb, t0b, twsb, twdb, headingb, twab, speedb, sailb, username, color = 'blue') {
                // circleBoatLayer.clearLayers()
                // var circleBoat = L.circle([y0vr, x0vr], { color: 'white', weight: 0.8, fillColor: '#f03', opacity: 1, fillOpacity: 0, radius: 250, }).bindTooltip(y0vr).addTo(circleBoatLayer);
                // var circleBoat2 = L.circle([y0vr, x0vr], { color: 'white', weight: 0.8, fillColor: '#f03', opacity: 1, fillOpacity: 0, radius: 500, }).bindTooltip(y0vr).addTo(circleBoatLayer);
                // desactive provisoire 
                boatMarkers.clearLayers()

                addBoatMarker(boatMarkers, username, yb, xb, {
                    color: color,
                    heading: headingb,
                    speed: speedb,
                    twa: twab,
                    twd: twdb,
                    tws: twsb,
                    sail: sailb,
                    baseSize: 25,
                    zoomRef: 13,
                });


                if (boatVisibility == 1) { boatMarkers.addTo(map) }
                else { boatMarkers.clearLayers() }
                circleBoatLayer.addTo(map)

            };












            function affichetabprogsvr(data) {   // affiche les programmations dans la case Programmationsvr   
                // differencie heading et waypoints

                programmationsJson = JSON.parse(data.programmations)

                if ("progs" in programmationsJson) {
                    programmationsvr = programmationsJson['progs']

                    texte = "<table class= 'table50'>"
                    for (var i = 0; i < programmationsvr.length; i++) {
                        if (programmationsvr[i][1] == 0) { option = 'Cap'; valeur = programmationsvr[i][2] }
                        else {
                            option = 'Twa';
                            if (programmationsvr[i][1] == -1) { valeur = -programmationsvr[i][2] } else { valeur = programmationsvr[i][2] }
                        }
                        texte += '<tr><td>A </td> <td> ' + hmn.format(programmationsvr[i][0] * 1000) + '</td><td>' + option + '</td> <td>' + valeur + '</td>    </tr>'
                    }
                    texte += "</table >"
                    document.getElementById('idprogrammationsvr').innerHTML = texte
                }
            }



            function affichetabwpvr(data) {
                //programmationsJson=JSON.parse(data.programmations)
                waypointsvr = JSON.parse(data.programmations)
                //   console.log ('on est dans affichage donnees waypoints')
                //   console.log (waypointsvr)
                //   waypointsvr=programmationsJson['progs']
                //   console.log ()

                let textewp = `<br>`

                for (let i = 0; i < waypointsvr.length; i++) {
                    textewp += `<span style="color: red;">  ${waypointsvr[i]['WPname']} </span>  ${pos_dec_mn_lat(waypointsvr[i]['WPLat'])} / ${pos_dec_mn_lng(waypointsvr[i]['WPLon'])}
     Vent ${waypointsvr[i]['WPTws'].toFixed(2)}N / ${waypointsvr[i]['WPTwd'].toFixed(2)}¬∞
     Twa ${waypointsvr[i]['WPTwam1'].toFixed(2)} / ${waypointsvr[i]['WPTwap1'].toFixed(2)}¬∞<br>
    ${typeVoilesShort[waypointsvr[i]['WPSailm1']]} / ${typeVoilesShort[waypointsvr[i]['WPSailp1']]}
    Duree ${formatTemps(parseInt(waypointsvr[i]['WPDuree']))} ETA ${hmns.format(waypointsvr[i]['WPEta'] * 1000)}
    NRJ ${waypointsvr[i]['WPNrjm1'].toFixed(1)} / ${waypointsvr[i]['WPNrjp1'].toFixed(1)}
    Peno ${waypointsvr[i]['WPPenop1'].toFixed(0)}s
    <br>
     <br><br>`

                }



                document.getElementById('idprogrammationsvr').innerHTML = textewp



            }





            function afficheligneprogs(data) {
                // Affiche la ligne des programmations sur la carte a partir des programmations recuperees dans progvr 

                //console.log('Mise a jour de la ligne de projection')
                progsvrLayer.clearLayers()
                // console.log ('data Ligne 1237  '+JSON.stringify(data))
                polylineprog = data.routeprogs
                typeprogs = data.typeprogs
                heurePremiereProg = polylineprog[0][0]        // premiere prog  
                // console.log('heure du premier point de la simulation ' + hmns.format(heurePremiereProg * 1000))   // c est le point 1 et non le point 0 
                // console.log('t0routage ' + t1routage + 'soit ' + hmns.format(t0routage * 1000))
                // console.log('t0progsvr ' + polylineprog[0][0] + 'soit ' + hmns.format(polylineprog[0][0] * 1000))
                // console.log('t1routage ' + t1routage)

                for (var i = 1; i <= polylineprog.length - 1; i++)                // on affiche les nouveaux points mais pas le premier pas necessaire 
                {

                    couleur = colors[polylineprog[i][5]]
                    voile = polylineprog[i][5]
                    nomvoile = typeVoilesShort[voile]
                    option = polylineprog[i][1]
                    if (option == 1) { nomOption = 'Twa' } else { nomOption = 'Cap' }

                    tooltipprog[i] = ' Programmations <br>' + intlhmn.format(polylineprog[i][0] * 1000) + '<br> ' + nomOption + ': ' + polylineprog[i][2].toFixed(1) + '¬∞<br> Voile :' + nomvoile              // le temps est en position 3
                    rayon = 10; tourcol = 'black'; poids = 1; opac = 0.5; fillopac = 1; fillCol = couleur;


                    if ((polylineprog[i][0] - t1routage) % 600 == 0) { rayon = 20; tourcol = 'black'; poids = 1; fillopac = 0.5 }   //Ecart de 10 mn avec le troutage
                    if ((polylineprog[i][0] - t1routage) % 3600 == 0) { rayon = 30; tourcol = 'White'; poids = 2; fillopac = 0.3; fillcol = couleur }   //Ecart de 10 mn avec le troutage
                    if ((polylineprog[i][2] != polylineprog[i - 1][2]) || (i == polylineprog.length - 1)) { rayon = 30; tourcol = 'black'; poids = 2; fillopac = 0.5; fillCol = 'red' }    // Changement de programmation ou dernier point         

                    circleprog[i] = L.circle([polylineprog[i][3], polylineprog[i][4]], { radius: rayon, color: tourcol, weight: poids, fillColor: fillCol, opacity: opac, fillOpacity: fillopac, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayer)


                    if (polylineprog[i][2] != polylineprog[i - 1][2]) {
                        // Rond central
                        circleprog3[i] = L.circle([polylineprog[i][3], polylineprog[i][4]], { radius: 1, color: 'black', weight: 1, fillColor: 'black', opacity: 0, fillOpacity: fillopac, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayer)
                    }

                }


                //     // on va aussi tracer les lignes
                for (var i = 0; i < polylineprog.length - 1; i++)                // on affiche les nouveaux points mais pas le premier pas necessaire 


                {
                    couleur = colors[polylineprog[i][5]]
                    polyglobal2[i] = L.polyline([[polylineprog[i][3], polylineprog[i][4]], [polylineprog[i + 1][3], polylineprog[i + 1][4]]], { color: couleur, weight: .5 }).addTo(progsvrLayer);

                }

                progsvrLayer.addTo(map)

                // il faudrait aussi changer le heading du bateau 

                // console.log (' on va reafficher le bateau pour '+username) 

                t0Secondes = polylineprog[0][0]
                y0 = polylineprog[0][3]
                x0 = polylineprog[0][4]
                sail = polylineprog[1][5]
                twavr = polylineprog[1][6]
                heading = polylineprog[1][7]
                speed = polylineprog[1][8]
                twdvr = polylineprog[0][9]
                twsvr = polylineprog[0][10]


                afficheBoat2(y0, x0, t0Secondes, twsvr, twdvr, heading, twavr, speed, sail, username, 'blue')

                // on va aussi changer les valeurs de twa et de heading dans la boite 



                document.getElementById('dateposvr').innerHTML = intlhmn.format(lastCalcDate)
                //  document.getElementById('usernamevr').innerHTML = username
                //  document.getElementById('y0vr').innerHTML = pos_dec_mn_lat(y0vr) + '(' + y0vr.toFixed(4) + ") "
                //  document.getElementById('x0vr').innerHTML = pos_dec_mn_lng(x0vr) + '(' + x0vr.toFixed(4) + ") "
                //  document.getElementById('twsvr').innerHTML = twsvr.toFixed(2)
                //  document.getElementById('twdvr').innerHTML = twdvr.toFixed(2)
                document.getElementById('twavr').innerHTML = twavr.toFixed(2)
                //  document.getElementById('rankvr').innerHTML = rankvr
                document.getElementById('speedvr').innerHTML = speed.toFixed(2)
                document.getElementById('sailvr').innerHTML = typeVoiles[(sail % 10) ]
                document.getElementById('headingvr').innerHTML = heading.toFixed(2)
                //document.getElementById('staminavr').innerHTML = stamina.toFixed(2)




            }







            function afficheligneprogsjaunes(polylineprog) {
                progsvrLayerJaune.clearLayers()
                console.log('heure du premier point de la simulation jaune ' + intlhmn.format(polylineprog[0][4] * 1000))
                try {
                    ecartmn = (polylineprog[0][4] - arrayroutage[0][3]) / 60
                    console.log(' temps initial du routage ' + intlhmn.format(arrayroutage[0][3] * 1000))
                    console.log(' ecart en mn  entre le routage et la simulation ' + ecartmn)
                }
                catch { console.log('pas encore de routage'); ecartmn = 0 }
                console.log('heure du premier point de la simulation jaune' + intlhmn.format(polylineprog[0][4] * 1000))

                for (var i = 1; i < polylineprog.length - 1; i++)                // on affiche les nouveaux points mais pas le premier pas necessaire 
                {
                    if (polylineprog[i][2] == 0) { option = 'Cap' } else { option = 'Twa' }
                    voile = typeVoiles[polylineprog[i][5]]
                    couleur = colors[polylineprog[i][5]]
                    tooltipprog[i] = intlhmn.format(polylineprog[i][4] * 1000) + '<br> ' + option + ' ' + polylineprog[i][3] + '<br>' + voile              // le temps est en position 3

                    if (polylineprog[i][3] == polylineprog[i - 1][3])          // si pas de changement de programmation  on fait des cercles noirs   
                    {
                        if ((i + ecartmn) % 10 != 0) { circleprog[i] = L.circle([polylineprog[i][0], polylineprog[i][1]], { fillColor: 'yellow', color: couleur, weight: 1, opacity: 1, fillOpacity: 0, radius: 100, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayerJaune) }
                        else {
                            circleprog[i] = L.circle([polylineprog[i][0], polylineprog[i][1]], { fillColor: 'white', color: 'black', weight: 1, opacity: 1, fillOpacity: 0, radius: 220, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayerJaune)

                            if ((i + ecartmn) % 60 == 0) { circleprog[i] = L.circle([polylineprog[i][0], polylineprog[i][1]], { fillColor: 'white', color: 'yellow', weight: 1, opacity: 1, fillOpacity: 0, radius: 260, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayerJaune) }

                        }
                    }

                    else {  //il y a un changement de programmation qui se decale automatiquement 
                        circleprog[i] = L.circle([polylineprog[i][0], polylineprog[i][1]], { fillColor: 'red', color: 'yellow', weight: 1, opacity: 1, fillOpacity: 100, radius: 260, }).bindTooltip(tooltipprog[i]).addTo(progsvrLayerJaune)
                    }
                }
                progsvrLayerJaune.addTo(map)
            }









            //------------------------------------------------------------------------------------     
            // Fonctions utilitaires 
            //------------------------------------------------------------------------------------  





            function verifierDeltat(deltat) {

                console.log('Temps depuis la derniere mise a jour   ' + parseInt(ecartTemps) + 's')
                boite = document.querySelector(".boite2");

                // V√©rifier si l'√©l√©ment overlay existe d√©j√†
                overlay = boite.querySelector(".boite-overlay");

                if (deltat > 540) {
                    if (!overlay) {
                        overlay = document.createElement("div");
                        overlay.classList.add("boite-overlay");
                        overlay.textContent = "La position date de plus de 10 mn";
                        boite.appendChild(overlay);
                    }
                } else {
                    if (overlay) {
                        overlay.remove();
                    }
                }
            }


            function ftabnamecourses(listetoutescourses)    // donne le tableau reduit des courses a partir de la listecomplete sous for me de chaine 
            {
                listetoutescourses = JSON.parse(listetoutescourses)
                nombreCourses = listetoutescourses['res'].length
                tabNameCourses.length = nombreCourses
                for (var i = 0; i < nombreCourses; i++) {
                    let coursei = listetoutescourses['res'][i]

                    numero = coursei['raceId'] + '.' + coursei['legNum']
                    startdate = coursei['startDate']
                    status = coursei['status']
                    polar_id = coursei['boat']['polar_id']
                    depart = [coursei['start']['lat'], coursei['start']['lon'], coursei['start']['name'], coursei['start']['heading'], coursei['start']['radius'],]
                    end = [coursei['end']['lat'], coursei['end']['lon'], coursei['end']['name'], coursei['end']['heading'], coursei['end']['radius'],]
                    tabNameCourses[i] = [numero, coursei['legName'] + ' (' + numero + ')', startdate, status, depart, end, polar_id];
                }
                return tabNameCourses

            }



            function tracearc(y0, x0, y1, x1) { //trace un arc entre les points 1 et 2
                L.Polyline.Arc([y0, x0], [y1, x1], {
                    color: 'white', weight: 1, vertices: 50, dashArray: '5, 5' // 5 pixels de ligne, 5 pixels d'espace
                }).addTo(lgDashLines)
            }


            function rechercheindice2(tabNameCourses, course) {
                for (var i = 0; i < tabNameCourses.length; i++)                             // on recupere la valeur des marques pour la course choisie
                {
                    if (course == (tabNameCourses[i][0]))      // si on est bien sur la course selectionnee val est renvoye par selectcourse 
                    { indice = i; break }
                    else { indice = 0 }
                }
                return indice
            }



            function generateSelect(id, tabValeurs, tabNoms, grises, selectini, class1) {
                // genere le html pour le select depart avec valeurs tabvaleurs noms tabnoms coursesuser =courses en cours  course = selection initiale 
                let selectHtml = '<select id="' + id + '"  class=' + class1 + '>';

                for (let i = 0; i < tabValeurs.length; i++) {
                    const value = tabValeurs[i];
                    const readableValue = tabNoms[i];
                    const style = grises.includes(value) ? 'black11grey' : 'black11';
                    //const style = value === selectini ? 'black11' : grises.includes(value) ? 'black11grey' : 'black11bold';

                    const selected = value === selectini ? ' selected' : '';
                    selectHtml += `<option value="${value}" class="${style}"${selected}>${readableValue}</option>`;
                }
                selectHtml += '</select>';
                return selectHtml;
            }


            function fselectarrivee(tabValues, tabNoms, tabSelected, class1) {

                // console.log('tabValues '+tabValues+ 'tabNoms '+ tabNoms+' ' + tabSelected+ 'class1 '+class1) 
                // G√©n√®re le HTML pour un <select> multiple
                let selectHtml = '<select multiple  id="idarrivee" class="' + class1 + '">';
                console.log('longueur ', tabValues.length)
                console.log('longueur ', tabValues.length, ' ' + tabNoms.length)
                console.log('longueur ', tabValues.length, ' ' + tabNoms.length + ' ' + tabSelected.length)


                for (let i = 0; i < tabValues.length; i++) {
                    const value = tabValues[i];
                    const readableValue = tabNoms[i];
                    const selected = tabSelected.includes(value) ? ' selected' : ''; // V√©rifier si la valeur est s√©lectionn√©e       
                    const style = tabSelected.includes(value) ? 'black11wblue' : 'black11'; // Appliquer le style black11grey si l'option est s√©lectionn√©e

                    selectHtml += `<option value="${value}" class="${style}"${selected}>${readableValue}</option>`;// Ajouter l'√©l√©ment <option>
                }
                selectHtml += '</select>';
                return selectHtml;
            }



            function afficheselectarrivee(waypoints, ari) {
                // G√©n√®re le HTML pour un <select> multiple

                if (typeof ari === "undefined") {
                    ari = ['Arrivee'];
                }

                console.log('On est dans afficheselectarrivee')
                console.log('ari  : ' + ari)
                console.log('waypoints :    ' + waypoints)
                console.log('leginfos dans selectarrivee\n' + leginfos)

                tabValues = waypoints.map(subArray => subArray[1]);
                tabNoms = waypoints.map(subArray => subArray[1]);

                if (ari == 0) { ari = ['Arrivee'] }
                tabSelected = ari
                class1 = 'black11ari'



                let selectHtml = '<select multiple  id="idarrivee" class="' + class1 + '">';
                for (let i = 0; i < tabValues.length; i++) {
                    const value = tabValues[i];
                    const readableValue = tabNoms[i];
                    const selected = tabSelected.includes(value) ? ' selected' : ''; // V√©rifier si la valeur est s√©lectionn√©e       
                    const style = tabSelected.includes(value) ? 'black11wblue' : 'black11'; // Appliquer le style black11grey si l'option est s√©lectionn√©e

                    selectHtml += `<option value="${value}" class="${style}"${selected}>${readableValue}</option>`;// Ajouter l'√©l√©ment <option>
                }
                selectHtml += '</select>';
                try {
                    nomdernierwp = ari[ari.length - 1]
                    document.getElementById('iddernierwp').innerHTML = '(' + nomdernierwp + ')'
                }
                catch { None }

                // console.log('selectHTML ' + selectHtml)
                document.getElementById('idselectarrivee').innerHTML = selectHtml

                return selectHtml;
            }







            function couperPolyligneLongitude(points) {
                const troncons = [];
                let tronconCourant = [];

                for (let i = 0; i < points.length - 1; i++) {
                    const [lat1, lon1] = points[i];
                    const [lat2, lon2] = points[i + 1];

                    // Ajouter le point actuel au tron√ßon courant
                    tronconCourant.push([lat1, lon1]);

                    // V√©rifier si une coupure au niveau de l'antim√©ridien est d√©tect√©e
                    if (Math.abs(lon1 - lon2) > 180) {
                        // Calculer le point d'intersection avec le m√©ridien
                        const t = (180 - Math.abs(lon1)) / (Math.abs(lon2 - lon1));
                        const latIntersection = lat1 + t * (lat2 - lat1);
                        const lonIntersection = lon1 > 0 ? 180 : -180;

                        // Ajouter le point d'intersection et terminer le tron√ßon courant
                        tronconCourant.push([latIntersection, lonIntersection]);
                        troncons.push(tronconCourant);

                        // D√©marrer un nouveau tron√ßon √† partir de l'autre c√¥t√© du m√©ridien
                        const newLon = lon1 > 0 ? -180 : 180;
                        tronconCourant = [[latIntersection, newLon]];
                    }
                }

                // Ajouter le dernier point et le dernier tron√ßon
                tronconCourant.push(points[points.length - 1]);
                troncons.push(tronconCourant);

                return troncons;
            }





            function formatDuree(seconds) {
                let h = Math.floor(seconds / 3600);
                let m = Math.floor((seconds % 3600) / 60);
                let s = seconds % 60;

                let resultat = [];
                if (h > 0) resultat.push(`${h}h`);
                if (m > 0) resultat.push(`${m}mn`);
                if (s > 0 || resultat.length === 0) resultat.push(`${s}s`);

                return resultat.join(" ");
            }




            //***************************************************************************************************************
            //********  Fonctions de gestion de localstorage                                   ******************************
            //***************************************************************************************************************



            async function initialise1() {

                console.log('Recherche Dernier trajet dans memoiretrajets ')
                //initialisememoiretrajets
                //const tabNameCourses= await chercheracesinfos() 
                tabNameCourses = await chercheracesinfos() // independant de tout 
                if (localStorage.getItem("memoiretrajets") === null) {
                    console.log('Memoiretrajets n existe pas ')
                    // on cr√©e un premier trajet pour Inconnu        
                    username = 'Bateau Inconnu'
                    course = tabNameCourses[0][0]
                    y0 = tabNameCourses[0][4][0]
                    x0 = tabNameCourses[0][4][1]
                    y1 = tabNameCourses[0][5][0]      // a voir avec les futures modi 
                    x1 = tabNameCourses[0][5][1]
                    r1 = tabNameCourses[0][5][4]
                    nomAr = tabNameCourses[0][5][2]
                    t0 = nowMSec / 1000
                    ari = ['Arrivee']
                    WP = [[1, 'Arrivee', y1, x1, r1]]
                    trajet[0] = username
                    trajet[1] = course
                    trajet[2] = y0
                    trajet[3] = x0
                    trajet[4] = y0
                    trajet[5] = x0
                    trajet[6] = t0
                    trajet[7] = y1
                    trajet[8] = x1
                    trajet[9] = -1     // dep
                    trajet[10] = 1234   //user_id
                    trajet[11] = ari    //ari
                    trajet[12] = WP
                    trajet[13] = 'Initialisation'
                    // on sauve 
                    localStorage.setItem('memoiretrajets', JSON.stringify([trajet]))
                    //On en profite aussi pour lui initialiser sa course par defaut 
                    coursesUser = [course]

                }

            }



            function ajoutetrajet(trajet) {  //ajoute le trajet en premi√®re position 
                memoiretrajets = JSON.parse(localStorage.getItem(nomlocalstorage))
                //console.log('memoiretrajets \n'+memoiretrajets)
                memoiretrajets.unshift(trajet)
                memoiretrajets = memoiretrajets.slice(0, 10); // Garder seulement les 10 premiers
                localStorage.setItem('memoiretrajets', JSON.stringify(memoiretrajets))
            }




            function trouvetrajet(username, course) {
                //trouve le trajet et le reinstalle en premi√®re position 

                let tableau = JSON.parse(localStorage.getItem(nomlocalstorage))
                // Trouver l'index du trajet
                let index = tableau.findIndex(ligne => ligne[0] === username && ligne[1] === course);
                if (index === -1) {
                    return []; // Retourner un tableau vide si rien n'est trouv√©
                }
                if (index > 0) { // L'√©l√©ment est trouv√© mais pas en premier
                    let ligneCible = tableau.splice(index, 1)[0]; // Extraire la ligne cibl√©e
                    tableau.unshift(ligneCible); // R√©ins√©rer en premi√®re position
                    localStorage.setItem('memoiretrajets', JSON.stringify(tableau)); // Mettre √† jour localStorage
                    return ligneCible;
                }

                console.log('ligne 836' + tableau[0])
                return tableau[0];  // L'√©l√©ment est d√©j√† en premi√®re position
            }




            

            function trouvetrajetcomplet(username, course) {
                //trouve le trajet et le reinstalle en premi√®re position et initialise les variables  
                // On commence par rechercher s il existe dans la base boatinfos


                let tableau = JSON.parse(localStorage.getItem(nomlocalstorage))


                // Trouver l'index du trajet
                let index = tableau.findIndex(ligne => ligne[0] === username && ligne[1] === course);
                if (index === -1) {
                    return []; // Retourner un tableau vide si rien n'est trouv√©
                }
                if (index > 0) { // L'√©l√©ment est trouv√© mais pas en premier
                    let trajet = tableau.splice(index, 1)[0]; // Extraire la ligne cibl√©e
                    tableau.unshift(trajet); // R√©ins√©rer en premi√®re position
                    localStorage.setItem('memoiretrajets', JSON.stringify(tableau)); // Mettre √† jour localStorage

                    username = trajet[0]
                    course = trajet[1]
                    ycoord = trajet[2]                 // Derniers coordonnees rentres
                    xcoord = trajet[3]
                    y0vr = trajet[4]                 // Derni√®re position VR 
                    x0vr = trajet[5]
                    t0 = trajet[6]                 // dernier temps de calcul
                    y1 = trajet[7]                 // derniers coordonn√©s de l 'arrivee 
                    x1 = trajet[8]
                    dep = trajet[9]                 // valeur de depart
                    user_id = trajet[10]                // c 'est un tableau ordre des waypoints
                    ari = trajet[11]
                    waypoints = trajet[12]
                    Source = trajet[13]
                    return trajet;
                }

                //console.log('ligne 836' + tableau[0])
               
            }






            function trouvederniertrajet() {
                // console.log('trouvederniertrajet Recherche dernier trajet dans localstorage')
                //cherche le dernier trajet et initialise directement les variables globales 
                //nomlocalStorage='memoiretrajets'
                memoiretrajets = JSON.parse(localStorage.getItem("memoiretrajets"))
                let trajet = memoiretrajets[0]
                username = trajet[0]
                course = trajet[1]
                ycoord = trajet[2]                 // Derniers coordonnees rentres
                xcoord = trajet[3]
                y0vr = trajet[4]                 // Derni√®re position VR 
                x0vr = trajet[5]
                t0 = trajet[6]                 // dernier temps de calcul
                y1 = trajet[7]                 // derniers coordonn√©s de l 'arrivee  
                x1 = trajet[8]
                dep = trajet[9]                 // valeur de depart
                user_id = trajet[10]
                ari = trajet[11]                // c 'est un tableau ordre des waypoints
                waypoints = trajet[12]
                Source = trajet[13]

                // console.log('Dans Local Storage Dernier Trajet enregistr√©' )
                // console.log(trajet)

                return trajet

            }



            function trouvederniertrajetcourse(course) {
                //trouve le trajet et le reinstalle en premi√®re position 

                let tableau = JSON.parse(localStorage.getItem(nomlocalstorage))
                // Trouver l'index du trajet
                let index = tableau.findIndex(ligne => ligne[1] === course);
                if (index === -1) {
                    return []; // Retourner un tableau vide si rien n'est trouv√©
                }
                if (index > 0) { // L'√©l√©ment est trouv√© mais pas en premier
                    let ligneCible = tableau.splice(index, 1)[0]; // Extraire la ligne cibl√©e
                    tableau.unshift(ligneCible); // R√©ins√©rer en premi√®re position
                    localStorage.setItem('memoiretrajets', JSON.stringify(tableau)); // Mettre √† jour localStorage
                    return ligneCible;
                }

                console.log('ligne 1878' + tableau[0])
                return tableau[0];  // L'√©l√©ment est d√©j√† en premi√®re position
            }




//   function trouvederniertrajetcourse( course) {
//                 //trouve le trajet et le reinstalle en premi√®re position et initialise les variables  
//                 // On commence par rechercher s il existe dans la base boatinfos


//                 let tableau = JSON.parse(localStorage.getItem(nomlocalstorage))


//                 // Trouver l'index du trajet
//                 let index = tableau.findIndex(ligne => ligne[1] === course);
//                 if (index === -1) 
//                 {
//                     return []; // Retourner un tableau vide si rien n'est trouv√©
//                 }
                
//                 if (index > 0) { // L'√©l√©ment est trouv√© mais pas en premier
//                     let trajet = tableau.splice(index, 1)[0]; // Extraire la ligne cibl√©e
//                     tableau.unshift(trajet); // R√©ins√©rer en premi√®re position
//                     localStorage.setItem('memoiretrajets', JSON.stringify(tableau)); // Mettre √† jour localStorage

//                     username = trajet[0]
//                     course = trajet[1]
//                     ycoord = trajet[2]                 // Derniers coordonnees rentres
//                     xcoord = trajet[3]
//                     y0vr = trajet[4]                 // Derni√®re position VR 
//                     x0vr = trajet[5]
//                     t0 = trajet[6]                 // dernier temps de calcul
//                     y1 = trajet[7]                 // derniers coordonn√©s de l 'arrivee 
//                     x1 = trajet[8]
//                     dep = trajet[9]                 // valeur de depart
//                     user_id = trajet[10]                // c 'est un tableau ordre des waypoints
//                     ari = trajet[11]
//                     waypoints = trajet[12]
//                     Source = trajet[13]
//                     return trajet;
//                 }
//  return tableau[0];  // c est la valeur de trajet qui a deja ete remis en premi√®re position par unshift
//             }







            function updateTrajet(username, course, trajet) {
                const KEY = 'memoiretrajets';

                // Lecture s√©curis√©e
                let memoiretrajets;
                try {
                    const raw = localStorage.getItem(KEY);
                    memoiretrajets = raw ? JSON.parse(raw) : [];
                } catch (e) {
                    console.warn('memoiretrajets corrompu, r√©initialisation.', e);
                    memoiretrajets = [];
                }
                if (!Array.isArray(memoiretrajets)) memoiretrajets = [];

                const normUser = String(username ?? '').trim();
                const normCourse = String(course ?? '');

                // Fonction de correspondance qui accepte tableaux OU objets
                const isSameTrajet = (row) => {
                    if (!row) return false;

                    if (Array.isArray(row)) {
                        const u = String(row[0] ?? '').trim();
                        const c = String(row[1] ?? '');
                        return u === normUser && c == normCourse; // == pour g√©rer "654.1" vs 654.1
                    }

                    if (typeof row === 'object') {
                        const u = String(row.username ?? '').trim();
                        const c = String(row.course ?? '');
                        return u === normUser && c == normCourse;
                    }

                    return false;
                };

                // Supprime l‚Äô√©ventuelle ligne existante (quelle que soit sa forme)
                const index = memoiretrajets.findIndex(isSameTrajet);
                if (index !== -1) memoiretrajets.splice(index, 1);

                // Ajoute la nouvelle ligne en t√™te
                memoiretrajets.unshift(trajet);

                // Sauvegarde
                localStorage.setItem(KEY, JSON.stringify(memoiretrajets));
            }









            function updateTrajet2(trajet) {
                // substitue le trajet si deja existant le cree sinon et le place en premier dans tous les cas  
                console.log('On est dans updateTrajet2')
                console.log('trajet propose pour la modif ')
                console.log(trajet)
                let memoiretrajets = JSON.parse(localStorage.getItem('memoiretrajets'));// R√©cup√©rer le tableau 
                console.log('memoiretrajets avant modif')
                console.log(memoiretrajets[0][12])
                memoiretrajets[0] = trajet; // Ajouter la nouvelle ligne en t√™te de liste
                // Sauvegarder dans le localStorage
                console.log('memoiretrajets apres modif')

                console.log(memoiretrajets[0][12])
                localStorage.setItem('memoiretrajets', JSON.stringify(memoiretrajets));
            }







            //***************************************************************************************************************
            //********  Fonctions asynchrones de recuperation des infos sur serveur            ******************************
            //***************************************************************************************************************




            async function recherchepersonalinfos(username, user_id, course) {
                // console.log('*********************************************************************')    
                // console.log ("On recherche les infos personelles de "+ username+" sur course "+ course+" avec recherchepersonalinfos ")
                // console.log('**********************************************************************')   


                const url = serveur + "/recherchepersonalinfos?username=" + username + "&user_id=" + user_id + "&course=" + course
                const response = await fetch(url);
                if (!response.ok) { throw new Error(`La recherche des infos perso a echou√©e : ${response.statusText}`); }
                const reponse = await response.json();

                infos = reponse['infos']
                // console.log ('infos '+infos )        

                // waypoints=infos['wp']
                // console.log ('Test de recuperation waypoints'+waypoints)
                return infos
            }



            async function newpersonalinfos(username, course) {
                // cree un personalinfos pour username et course 
                // on va envoyer les donnees recuperees pour la course a partir de tabnamecourses 
                let courseencours = tabNameCourses.find(tabNameCourses => tabNameCourses[0] === course)
                console.log(courseencours)
                courseencours = JSON.stringify(courseencours)
                const url = serveur + "/newpersonalinfos?username=" + username + "&course=" + courseencours
                const response = await fetch(url);
                if (!response.ok) { throw new Error(`La recherche des infos perso a echou√©e : ${response.statusText}`); }
                const reponse = await response.json();
                message = reponse['message']
                console.log('message : ' + message)

                // waypoints=infos['wp']
                // console.log ('Test de recuperation waypoints'+waypoints)
                return message

            }



            // requete en post base personalinfos sur serveur 
            async function modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nom, valeur) {
                //  valeur = encodeURIComponent(valeur);

                const url = serveur + "/modifpersonalinfos";

                const data = {
                    username: username,
                    course: course,
                    user_id: user_id,
                    typeinfo: typeinfo,
                    typeaction: typeaction,
                    nom: nom,
                    valeur: valeur
                };

                console.log("Donn√©es envoy√©es :", data);

                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(data)
                });

                if (!response.ok) {
                    throw new Error(`La modification des infos perso a √©chou√© : ${response.statusText}`);
                }

                const reponse = await response.json();
                message = reponse['message'];
                console.log("Message re√ßu :", message);

                return message;
            }



            async function chercheracesinfos() {
                const url = serveur + "/rechercheracesinfos";
                try {
                    const response = await fetch(url);
                    if (!response.ok) { throw new Error(`La liste des courses generales  n'a pas √©t√© trouv√©e : ${response.statusText}`); }
                    const data = await response.json();
                    const listetoutescourses = data.result; // Donn√©es brutes
                    // console.log ('data.result '+data.result) 

                    let tabNameCourses = ftabnamecourses(listetoutescourses);                   // Simplification des donnees en Tableau
                    tabNameCourses = tabNameCourses.filter(course => course[3] !== 'ended');
                    console.log('Tableau des courses en cours')
                    console.log(tabNameCourses)
                    return tabNameCourses;
                } catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de chercheracesinfos :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }




            async function cherchecoursesuser(username) {
                const url = serveur + "/recherchecoursesuser?username=" + username
                try {
                    let response = await fetch(url,);
                    if (!response.ok) { throw new Error('La liste des coursesuser  n a pas ete trouvee ' + response.statusText); }
                    let data = await response.json();
                    coursesUser = data.result

                    // console.log('coursesUser  recuperees sur le serveur ')
                    // console.log (coursesUser)
                    user_id = coursesUser[0]

                    //console.log('User, Courses User :  ' + coursesUser)
                    // console.log('ligne 2119 User_id :  ' + user_id)
                    // console.log ('ligne 1422 Courses User :  '+coursesUser[1])

                    if (user_id) { registerClientId(user_id); }

                    if (coursesUser == null) { //alert ('Ce bateau n est inscrit sur aucune course, il n\'est pas possible d utiliser la position VR   ') ;
                        course = tabNameCourses[0][0];
                        coursesUser = [course]
                    }
                    else {
                        coursesUser = JSON.parse(coursesUser[1])// on transforme le tableau de json en tableau simle
                        coursesUser = coursesUser.map(item => `${item.raceId}.${item.legNum}`)
                    }

                    return coursesUser
                }

                catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de cherchecoursesuser :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }









            async function chercheleginfos(course) {
                const url = serveur + "/rechercheleginfos?course=" + course
                try {
                    let response = await fetch(url,);
                    if (!response.ok) { throw new Error('chercheleginfos n a pas repondu ' + response.statusText); }
                    let data = await response.json();
                    leginfos = data.result
                    return leginfos
                }
                catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de chercheleginfos :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }




            async function chargecartemaps2(lat, lon) {
                const url = serveur + "/chargecarte3?lat=" + lat + "&lon=" + lon
                try {
                    let response = await fetch(url,);
                    if (!response.ok) { throw new Error('chargecarte n a pas repondu ' + response.statusText); }
                    let reponse = await response.json();
                    carte = reponse.carte
                    return carte
                }
                catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de chercheleginfos :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }



            async function chercheprogsvr(user_id, course, t0routage) {
                // console.log('Recherche des Progs\n*********************************')
                // console.log (' ligne 1277 '+t0routage)
                progsvrLayer.clearLayers()
                if (!t0routage) {
                    let nowJS = new Date();
                    let nowSec = nowJS.getTime() / 1000;
                    let nowSecArrondi = Math.ceil(nowSec / 60) * 60;
                    t0routage = nowSecArrondi
                }


                // console.log (' ligne 1282 '+t0routage)
                // console.log (' ligne 1365 user_id'+user_id)

                const url = serveur + "/rechercheprogsvr?user_id=" + user_id + "&course=" + course + "&t0routage=" + t0routage
                //console.log('ligne 1833  demande de rechercheprogsvr url \n' + url)

                let response = await fetch(url);
                if (!response.ok) { throw new Error('Probl√®me avec cherche Progsvr ' + response.statusText); }
                data = await response.json();

                afficheligneprogs(data) // on va l afficher dans leaflet 

                if (data['typeprogs'] == 'progs') { affichetabprogsvr(data) }
                if (data['typeprogs'] == 'wps') { affichedatawaypoints(data) }
                bloque = 0

            }



            function affichetabprogsvr(data) {   // affiche les programmations dans la case Programmationsvr   
                // differencie heading et waypoints

                programmationsvr = data.programmations['progs']

                texte = "<table class= 'table50'>"
                for (var i = 0; i < programmationsvr.length; i++) {
                    if (programmationsvr[i][1] == 0) { option = 'Cap'; valeur = programmationsvr[i][2] }
                    else {
                        option = 'Twa';
                        if (programmationsvr[i][1] == -1) { valeur = -programmationsvr[i][2] } else { valeur = programmationsvr[i][2] }
                    }
                    texte += '<tr><td>'+(i+1)+') </td> <td> ' + hmn.format(programmationsvr[i][0] * 1000) + '</td><td>' + option + '</td> <td>' + valeur + '</td>    </tr>'
                }
                texte += "</table >"
                document.getElementById('idprogrammationsvr').innerHTML = texte

            }




            function affichedatawaypoints(data) {   // affiche les programmations dans la case Programmationsvr   


                textebutton = " <button  id='affichedatawaypoints' class='blackwhite11' value='Afficher' > Afficher les donnees WayPointsVR </button>"
                document.getElementById('idprogrammationsvr').innerHTML = textebutton
                document.getElementById("idprogrammationsvr").onclick = function () {


                    testPopup = window.open("", "_blank", "width=800,height=800");
                    sections = data.sections
                    let texte2 = "<table border='1' cellpadding='4' cellspacing='0'><thead><td>Cl√©</td>";
                    sections.forEach((_, i) => {
                        texte2 += `<td>WP[${i + 1}]</td>`;
                    });
                    texte2 += "</tr>";

                    // Lignes
                    const keys = Object.keys(sections[0]);
                    keys.forEach(key => {
                        texte2 += `<tr><td>${key}</td>`;
                        sections.forEach(s => {
                            texte2 += `<td>${formatValue(key, s[key])}</td>`;
                        });
                        texte2 += "</tr>";
                    });

                    texte2 += "</table>";
                    testPopup.document.write(texte2);



                }
            }



            function formatValue(key, value) {
                if (key.startsWith("t_start") || key.startsWith("t_end")) {
                    const d = new Date(value * 1000);
                    const h = d.getHours().toString().padStart(2, '0');
                    const m = d.getMinutes().toString().padStart(2, '0');
                    return `${h}:${m}`;
                }
                if (["cap", "tws", "tws_end", "twd", "twd_end"].includes(key)) {
                    return value.toFixed(2);
                }
                if (["x0", "x1", "y0", "y1"].includes(key)) {
                    return value.toFixed(4);
                }
                return Math.round(value).toString();
            }







            async function cherchevoiles(y0, x0, t0, tws, twa, polar_id) {

                const url = serveur + "/recherchevoiles?y0=" + y0 + "&x0=" + x0 + "&t0=" + t0 + "&tws=" + tws + "&polar_id=" + polar_id
                //console.log ('url'+url)
                let response = await fetch(url);
                try {
                    if (!response.ok) { throw new Error('Probl√®me avec cherchevoiles ' + response.statusText); }
                    resvoiles = await response.json();
                    // console.log('resvoiles'+resvoiles)
                    // on lance ici directement l affichage pour pouvoir utiliser la fonction dans les mises a jour 
                    twscalc = resvoiles.twscalc
                    twdcalc = resvoiles.twdcalc
                    tabvmg = resvoiles.tabvmg
                    tabrecouvrements = resvoiles.tabrecouvrements
                    // on affiche les valeurs 
                    document.getElementById('twscalc').innerHTML = twscalc.toFixed(2)
                    document.getElementById('twdcalc').innerHTML = twdcalc.toFixed(2)
                    document.getElementById('vmgmin2').innerHTML = tabvmg[2].toFixed(1)
                    document.getElementById('vmgmax2').innerHTML = tabvmg[4].toFixed(1)
                    document.getElementById('vmax2').innerHTML = tabvmg[6].toFixed(1)
                    affichagerecou(tabrecouvrements)
                    // on en profite pour mettre ajour le lien sur les polaires avec tws et twa 
                    return resvoiles
                }
                catch (error) {
                    console.error("Erreur lors de la r√©cup√©ration de cherchevoiles :", error);
                    throw error; // Propager l'erreur pour que l'appelant puisse la g√©rer
                }
            }



            async function calculeroute(user_id, course, programmations, voilesauto) {
                // avant d envoyer la demande de calcul au serveur on uniformise la premiere date jaune avec les programmations rouges

                console.log(' ligne 706 heure de la premiere programmation jaune ' + hmns.format(programmations[0][0] * 1000))
                console.log(' ligne 706 heure de la premiere programmation rouge ' + hmns.format(heurePremiereProg * 1000))
                programmations[0][0] = heurePremiereProg
                const progs5 = JSON.stringify(programmations);        // pour envoi par url 

                //console.log('ligne 1332 '+progs5)

                url = serveur + "/calculeroute?username=" + username + "&user_id=" + user_id + "&course=" + course + "&programmations=" + progs5 + "&voilesauto=" + voilesauto
                let response = await fetch(url);
                if (!response.ok) { throw new Error('Probleme dans calculroute ' + response.statusText); }
                let data = await response.json();
                polylineprog = data.polylineprog
                //console.log (polylineprog)
                afficheligneprogsjaunes(polylineprog)// il n y a plus qu a tracer 
            }



            async function majgrib() {

                url = serveur + `/majgrib`
                let response = await fetch(url);
                if (!response.ok) { throw new Error('Probleme dans majgrib ' + response.statusText); }
                let data = await response.json();

            }



            async function calculeroutage(y0, x0, heuredepart, waypoints, ari, cocheexclusions) {
                // on va tout transmettre sauf waypoints qui est deja dans personalinfos pour eviter d avoir a faire 2 versions completement differentes 
                let isMe='yes'

                console.log ('username')
                username2 =document.getElementById('idusername').value
                if (username2!=username){console.log('On ne route pas le bateau principal'); isMe='no'}


                console.log('On est dans calculeroutage')
                routageLayer.clearLayers()
                isochronesLayer.clearLayers()
                strari        = JSON.stringify(ari)
                const select  = document.getElementById('iddepart');
                optionroutage = select.value    // option de routage position et heure vr , positionmanuelle   ou position depart heure depart course 
                console.log('optionroutage ' + optionroutage)

                // on va lancer la progressbar
                    console.log('ari ' + ari)
                    console.log(' waypoints ')
                    console.log(waypoints)
                    let lastName = ari[ari.length - 1];
                    // recherche dans waypoints du tableau correspondant
                    let found = waypoints.find(wp => wp[1] === lastName);
                    if (found) {
                        let latcible = found[2];
                        let loncible = found[3];
                        console.log("lat =", latcible, "lon =", loncible);
                        progressbar(y0, x0, latcible, loncible)
                    }

                url = serveur + `/calculeroutage?course=${course}&user_id=${user_id}&isMe=${isMe}&y0=${y0}&x0=${x0}&t0=${heuredepart}&ari=${strari}&tolerancehvmg=${tolerancehvmg}&cocheexclusions=${cocheexclusions}&optionroutage=${optionroutage}`

                //console.log('t0 issu de calculeroutage et transmis par l url  ' + intlhmn.format((heuredepart * 1000)))

                console.log('\nDemande de routage url : ' + url + '\n***************************************************************************')
                let response = await fetch(url); if (!response.ok) { throw new Error('Le routage n a pas pu etre calcul√© ' + response.statusText); }

                // recuperation des donnees de routage
                let data = await response.json();
                message = data.message
                tabroutage = data.arrayroutage2
                //tabroutage2 = data.arrayroutage
                dicoIsochrones = data.isochrones
                t1routage = data.t0routage                    // temps initial du routage
                tabtempsroutage = tabroutage.map(row => row[1] + t1routage)
                tc = tabtempsroutage
                console.log('t0routage issu de calculeroutage ' + hmns.format((t0routage * 1000)))

                // affichage de la route avec les tooltips 
                for (var i = 1; i <= tabroutage.length - 1; i++)                // on affiche les nouveaux points mais pas le premier pas necessaire 
                {
                    couleur = colors[tabroutage[i][10]]
                    voile = tabroutage[i][10]
                    nomvoile = typeVoilesShort[voile]
                    twa = tabroutage[i][5].toFixed(2)
                    tws = tabroutage[i][12].toFixed(2)
                    twd = tabroutage[i][13].toFixed(2)
                    cap = tabroutage[i][6].toFixed(2)
                    date = intlhmn.format((t0routage + tabroutage[i][1]) * 1000)
                    vmgmin = tabroutage[i][7]
                    vmgmax = tabroutage[i][8]
                    vmg = twa < 90 ? vmgmin : vmgmax

                    tooltipprog[i] = '<b> Point ' + i + ' le ' + date + ' <br>(Routage du ' + intlhmn.format((heuredepart * 1000)) + ')</b>  <br> Twa ' + twa + '¬∞  Vmg ' + vmg + '¬∞<br>Tws ' + tws + ' Twd ' + twd + ' <br>Cap : ' + cap + '  Voile :' + nomvoile              // le temps est en position 3
                    tourcol = 'red'; opac = 1; poids = 1; fillopac = 0.5; fillCol = couleur; rayon = 10;       // valeur par defaut  
                    if (i % 10 == 0) { rayon = 20, tourcol = 'red'; fillopac = 0.5 }              // tous les 10    
                    if (tabroutage[i][1] % 3600 == 0) { tourcol = 'white'; rayon = 50, fillopac = 0.5 }                    // toutes les heures 
                    circleprog[i] = L.circle([tabroutage[i][2], tabroutage[i][3]], { fillColor: fillCol, color: tourcol, weight: poids, opacity: opac, fillOpacity: fillopac, radius: rayon, })
                        .bindTooltip(tooltipprog[i]).bindPopup(tooltipprog[i]).addTo(routageLayer)
                }





                for (var i = 0; i <= tabroutage.length - 2; i++)                // on affiche les nouveaux points mais pas le premier pas necessaire 
                {
                    couleur = colors[tabroutage[i][10]]
                    polyglobal[i] = L.polyline([[tabroutage[i][2], tabroutage[i][3]], [tabroutage[i + 1][2], tabroutage[i + 1][3]]], { color: couleur, weight: 1 }).addTo(routageLayer);
                }






                routageLayer.addTo(map)


                // console.log('dicoIsochrones')
                // console.log(dicoIsochrones[0])
                // console.log(dicoIsochrones[1])
                // console.log(dicoIsochrones.length)

                // affichage des isochrones 

                isochronesLayer.clearLayers()

                // if (Array.isArray(dicoIsochrones)) {
                //     console.log("C'est un tableau, longueur =", dicoIsochrones.length);
                // } else if (typeof dicoIsochrones === 'object') {
                //     console.log("C'est un objet avec", Object.keys(dicoIsochrones).length, "cl√©s");
                // } else if (typeof dicoIsochrones === 'string') {
                //     console.log("C'est une cha√Æne JSON ?");
                // }



                // On transforme l'objet en tableau
                let arrIso = Object.values(dicoIsochrones);
                console.log("Nombre d'isochrones :", arrIso.length);

                // Boucle sur le tableau
                arrIso.forEach((points, idx) => {
                    const couleur = (idx % 6 === 0) ? 'white' : 'black';

                    // Cas : plusieurs polylines (tableau de tableaux de points)
                    if (Array.isArray(points[0][0])) {
                        points.forEach(poly => {
                            L.polyline(poly, {
                                color: couleur,
                                weight: 1,
                                opacity: 1
                            }).bindTooltip('iso : ' + idx).addTo(isochronesLayer);
                        });
                    }
                    // Cas : une seule polyline (tableau de points)
                    else {
                        L.polyline(points, {
                            color: couleur,
                            weight: 1,
                            opacity: 1
                        }).bindTooltip('iso : ' + idx).addTo(isochronesLayer);
                    }
                });









                let checkboxiso = document.getElementById('showisochrones')
                if (checkboxiso.checked) {
                    // Ajouter le layer des isochrones √† la carte
                    isochronesLayer.addTo(map);
                }


                // affichage du tableau de routage 
                arrayroutage = tabroutage   // ("c'est arrayroutage qui est utilise dans createtexte")
                texteroute = createTexteRoute()
                // console.log ('texteroute '+texteroute)
                document.getElementById('detailroute2').innerHTML = " <button  >Detail Route </button>"


                // on va sauver les caracteristiques du routage dans memoire trajet
                trajet = trouvederniertrajet()
                console.log(' Ligne 2176 trajet ')
                console.log(trajet)

                trajet = [username, course, y0, x0, y0, x0, heuredepart, y1, x1, optionroutage, user_id, ari, waypoints, 'maj suite routage']
                updateTrajet(username, course, trajet)
                console.log('mise a jour de memoiretrajet ')
                console.log('Nouveau trajet enregistr√©  dans localstorage ')
                console.log(trajet)

            }       //fin de calcul du routage







            //***************************************************************************************************************
            //********  Fonctions de validation de l input                                     ******************************
            //***************************************************************************************************************



            function waitForInput() {
                return new Promise((resolve) => {
                    usernameInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { // Si "Entr√©e" est press√©e
                            if (validateInput()) {
                                resolve(usernameInput.value.trim()); // R√©sout avec la valeur
                            }
                        }
                    });
                });
            }

            function validateInput() {
                const value = usernameInput.value.trim();
                if (value === "") {
                    alert("Veuillez entrer un nom d'utilisateur avant de continuer.");
                    usernameInput.focus(); // Re-mets le focus sur le champ
                    return false;
                }
                return true;
            }


            function recuperecoordsdep() {
                var latDeg = document.getElementById("deplatDeg").value;
                var latMin = document.getElementById("deplatMin").value;
                var latSec = document.getElementById("deplatSec").value;
                var latDir = document.getElementById("deplatDir").value;
                var lngDeg = document.getElementById("deplngDeg").value;
                var lngMin = document.getElementById("deplngMin").value;
                var lngSec = document.getElementById("deplngSec").value;
                var lngDir = document.getElementById("deplngDir").value;
                return toDecimal(latDeg, latMin, latSec, latDir, lngDeg, lngMin, lngSec, lngDir);
            }

            function recuperecoordsari() {
                var latDeg = document.getElementById("arilatDeg").value;
                var latMin = document.getElementById("arilatMin").value;
                var latSec = document.getElementById("arilatSec").value;
                var latDir = document.getElementById("arilatDir").value;
                var lngDeg = document.getElementById("arilngDeg").value;
                var lngMin = document.getElementById("arilngMin").value;
                var lngSec = document.getElementById("arilngSec").value;
                var lngDir = document.getElementById("arilngDir").value;
                return toDecimal(latDeg, latMin, latSec, latDir, lngDeg, lngMin, lngSec, lngDir);
            }




            //***************************************************************************************************************
            //********  Gestion des waypoints                                       ******************************
            //***************************************************************************************************************
            // 2739 dblclick
            // 2790 ajoutewaypoint3
            // 2845 ouvrirEditeurWaypoint
            // 2898 ajoutewaypoint2
            // 2895 uvrirEditeurModifWaypoint
            // 2988 miseajourWaypoint2

            // 3050 fermerediteur
            // 3063 Gestionnaire de suppression 
            //   affichewaypoints2     permet d afficher les waypoints au demarrage 

            // miseajourwaypoint 
            // ajouterwaypoint
            // supprimerdulocalstorage
            // affichewaypoints 


            let circles = []; // Pour stocker le cercle actuel
            let newCircle = null;     // Cercle temporaire
            let newlat;
            let newlon;
            let newRayon;
            let waypointSauve = false;
            var waypointCircles2 = {}; // Stocke les cercles cr√©√©s pour √©viter les doublons
            var waypointsJS = {}; // Stocke les cercles cr√©√©s pour √©viter les doublons



            map.on('dblclick', function (e) {
                var lat = e.latlng.lat;
                var lon = e.latlng.lng;
                var couleur = "#FFFF00"; // Jaune par d√©faut
                var rayon = 0.5;         // ce sont des miles nautiques 

                console.log('lat ' + lat + ' lng ' + lon)
                console.log('Waypoints avant enregistrement du nouveau ')
                console.log(waypoints)

                const filtres = waypoints.filter(wp => wp[0] !== 99);     // waypoints sans arrivee 

                console.log('waypoints filtres ' + filtres)


                let nouveauNom, numero;

                if (filtres.length === 0) {
                    // Aucun WP pr√©sent
                    nouveauNom = "WP1";
                    numero = 1;
                }

                else {
                    // Trouver le waypoint avec l‚Äôindice max
                    const dernierWP = filtres.reduce((max, wp) => wp[0] > max[0] ? wp : max);
                    const ancienNom = dernierWP[1];
                    const match = ancienNom.match(/^([A-Za-z]+)(\d+)$/);
                    console.log('ancien nom ' + ancienNom)



                    if (match) {
                        const prefixe = match[1];
                        numero = parseInt(match[2], 10) + 1;
                        nouveauNom = `${prefixe}${numero}`;



                    } else {
                        // Si le nom n‚Äôest pas du type WP3, on recommence √† WP1
                        nouveauNom = "WP1";
                        numero = 1;
                    }
                }

                console.log("Nouveau nom :", nouveauNom);
                console.log("Nouveau Num√©ro :", numero);


                // Creation du nouveau cercle
                var newCircle = L.circle([lat, lon], {
                    color: 'black',
                    fillColor: couleur,
                    fillOpacity: 0.5,
                    radius: rayon * 1852,    // Stockage et affichage leaflet se fait en metres
                    draggable: true
                }).bindTooltip(nouveauNom)
                    .addTo(WpCirclesLayer);

                newCircle.on('drag', function (event) {
                    cercleSelectionne = newCircle;
                    const newLatLng = event.target.getLatLng();
                    document.getElementById('wpLat').textContent = newLatLng.lat.toFixed(4);
                    document.getElementById('wpLon').textContent = newLatLng.lng.toFixed(4);
                    ouvrirEditeurModifWaypoint(newCircle, nouveauNom, couleur);
                });

                newCircle.on('click', function () {
                    ouvrirEditeurModifWaypoint(newCircle, nouveauNom, couleur);
                });
                // ajout du newcircle dans waypointsJS
                waypointsJS[nouveauNom] = newCircle;
                console.log('Tout va bien ')
                var waypointEditor = document.getElementById("waypointEditor");
                console.log('Tout va bien 2')

                waypointEditor.style.display = "block";

                console.log('Tout va bien 3')
                waypointEditor.classList.add("visible");

                console.log(' ')
                console.log('on ouvre l editeur de waypoints avec nouveau nom  ' + nouveauNom)

                ouvrirEditeurWaypoint(newCircle, nouveauNom, numero, couleur); // Ouvre l'√©diteur avec les parametres 



            });





            function ouvrirEditeurWaypoint(cercle, nom, numero, couleurParDefaut = "#FFFF00") // Jaune par d√©faut {    // mis a jour 
            {
                console.log('ouverture de l editeur ')

                const waypointEditor = document.getElementById("waypointEditor");
                waypointEditor.style.display = "block";
                waypointEditor.classList.add("visible");

                const latLng = cercle.getLatLng();
                var lat = latLng.lat;
                var lon = latLng.lng;
                var rayon = cercle.getRadius() / 1852; // on obtient des m que l on convertit en  NM
                var couleurCercle = cercle.options.fillColor;
                var couleur = couleurParDefaut || couleurCercle; // Priorit√© √† la couleur par d√©faut si fournie

                document.getElementById('wpName').textContent = nom;
                document.getElementById('wpLat').textContent = lat.toFixed(4);
                document.getElementById('wpLon').textContent = lon.toFixed(4);
                document.getElementById('wpRadius').value = rayon;
                document.getElementById('wpColor').value = couleur; // S'assurer que la couleur est bien affich√©e

                cercleSelectionne = cercle;    // ? 

                // Mise √† jour du rayon en temps r√©el
                document.getElementById('wpRadius').oninput = function () {
                    var newRayon = parseFloat(this.value);         //  la on a une valeur  en MN 
                    cercle.setRadius(newRayon * 1852);             // pour l affichage on convertit en m
                };

                // Mise √† jour de la couleur en temps r√©el
                document.getElementById('wpColor').oninput = function () {
                    var newCouleur = this.value;
                    cercle.setStyle({ fillColor: newCouleur });
                };

                // sauvegarde du waypoint  si bouton savewaypoint
                document.getElementById("saveWaypoint").onclick = function () {
                    console.log(' on est dans onclick savewaypoint')
                    // la fonction ajoutewaypoint2 sauve dans la base et dans localstorage  # ici le rayon sauve est en mn
                    ajouteWaypoint2(numero, nom, lat, lon, parseFloat(document.getElementById('wpRadius').value), document.getElementById('wpColor').value);
                    waypointSauve = true;
                    // afficheselectarrivee(waypoints, ari)
                    fermerEditeurWaypoint();


                };
            }



            async function ajouteWaypoint2(numero, nomwp, latwp, lonwp, rayonwp, colorwp) {                                     //nouvelleversion 
                // ajoute le waypoint dans personalinfos et dans localstorage

                console.log('On est dans ajoutewaypoint2 ')
                // console.log ('liste complete des waypoints avant ajout')   
                // console.log (waypoints)
                typeinfo = 'wp';
                typeaction = 'insert';
                nouveauWP = [numero, nomwp, latwp, lonwp, rayonwp, colorwp]
                // nouveauWPStr = JSON.stringify(nouveauWP)

                message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nomwp, nouveauWP)     // ancienneement nouveauWPStr

                console.log('Ligne2805\n****************************************************************')

                console.log('Ligne 2893 liste waypoints avant ajout ')
                console.log(waypoints)
                waypoints.splice(waypoints.length - 1, 0, nouveauWP);
                nbWP += 1
                newwaypoints = waypoints
                console.log('Ligne 2898 liste complete des waypoints apres ajout')   // la c est bon 
                console.log(newwaypoints)
                trajet = trouvederniertrajet()     // attention rechearge les anciennes valeurs de waypoints et ari 
                trajet[12] = newwaypoints
                waypoints = newwaypoints            // necessaire pour que lors de l update les waypoints ne reviennent  pas a l ancienne valeur 
                console.log(username + ' \n' + course + '\n' + trajet)
                updateTrajet(username, course, trajet)

                console.log('nomWaypoints apres ajout ligne 2904 \n' + waypoints)
                // console.log ('ari'+ari)   


                afficheselectarrivee(newwaypoints, ari)

            }


            function ouvrirEditeurModifWaypoint(cercle, nom, couleurParDefaut = "#FFFF00") {
                const waypointEditor = document.getElementById("waypointEditor");
                waypointEditor.style.display = "block";
                waypointEditor.classList.add("visible");

                const latLng = cercle.getLatLng();
                var lat = latLng.lat;
                var lon = latLng.lng;
                var rayon = cercle.getRadius() / 1000 * 1.852; //  on obtient une valeur en m que l onconvertit en mN
                var couleur = cercle.options.fillColor; // R√©cup√©ration de la couleur actuelle

                document.getElementById('wpName').textContent = nom;
                document.getElementById('wpLat').textContent = lat.toFixed(4);
                document.getElementById('wpLon').textContent = lon.toFixed(4);
                document.getElementById('wpRadius').value = rayon;
                document.getElementById('wpColor').value = couleur;
                cercleSelectionne = cercle; // Mettre √† jour le cercle s√©lectionn√©

                // Mise √† jour du rayon en temps r√©el √† l ecran 
                document.getElementById('wpRadius').oninput = function () {
                    var newRayon = parseFloat(this.value);                                     // la c est une valeur en MN
                    cercle.setRadius(newRayon * 1000 / 1.852);                          // pour l affichage a l ecran on  convertit  les mn en m
                };


                //  <td><input type="color" value="${route.couleur}" oninput="changerCouleurRoute(${i}, this.value)"></td>  

                // Mise √† jour de la couleur en temps r√©el
                document.getElementById('wpColor').oninput = function () {
                    var newCouleur = this.value;
                    document.getElementById('wpColor').value = newCouleur
                    console.log('newCouleur ' + newCouleur)
                    cercle.setStyle({ fillColor: newCouleur });
                };



                document.getElementById("saveWaypoint").onclick = function () {
                    wpRadius = parseFloat(document.getElementById('wpRadius').value)      //la c est une valeur en mN de la boite de dialogue 

                    wpColor = document.getElementById('wpColor').value

                    console.log(`on declenche miseajourwaypoint2 avec nom ${nom} lat${lat} lon${lon}  wpradius${wpRadius}  color ${wpColor}`)
                    miseajourWaypoint2(nom, lat, lon, wpRadius, wpColor);
                    waypointSauve = true;
                    fermerEditeurWaypoint();
                };
            }



            async function miseajourWaypoint2(nomwp, newLat, newLon, newRayon, newColor) {
                // cette fonction sert pour le cas de l insertion ou de la modification 
                let ordre = parseInt(nomwp.slice(2));                                                                        //mis ajour 
                console.log('On est dans miseajourWaypoint2 ')
                console.log(`Dans miseajourwaypoint2 avec ordre ${ordre}  nom ${nomwp} lat${newLat} lon${newLon}  wpradius${newRayon}  color ${newColor}`)

                // la numerotation sera reprise 
                // on l ajoute dans le select ari 
                // on recupere la valeur du rayon newrayon en mN   et on le sauve en mN  

                typeinfo = 'wp'
                typeaction = 'modify',
                    nouveauWP = [ordre, nomwp, newLat, newLon, newRayon, newColor]
                nouveauWPStr = JSON.stringify(nouveauWP)
                console.log('WPStr modifi√© ' + nouveauWPStr)
                message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nomwp, nouveauWPStr)


                console.log('waypoints recuperes du global ')
                console.log(waypoints)

                // Dans waypoints On va changer le waypoint corrrespondant par le nom  
                let index = waypoints.findIndex(wp => wp[1] === nomwp);
                if (index !== -1) {
                    waypoints[index] = nouveauWP;
                } else {
                    console.warn("Nom de waypoint non trouv√© :", nomwp);
                }


                // il faut ajouter le wp a la liste 
                // console.log('ordre '+ordre)
                // waypoints[ordre-1]=nouveauWP       // on substitue les nouvelles valeurs dans les wp 
                // //waypoints.splice(waypoints.length - 1, 0, nouveauWP);
                waypointsnew = waypoints
                // console.log (' ligne 2908 waypoints apres modification  '+waypoints) // jusque la ok

                // Il faut le mettre a jour dans Localstorage
                let trajet = trouvederniertrajet()
                trajet[12] = waypointsnew

                console.log('trajet [12 ] apres modif ')
                console.log(JSON.stringify(trajet[12]))

                console.log('******************************************************************************')


                // console.log ('trajet apres modif ' )
                // console.log (trajet)
                // console.log('******************************************************************************')

                updateTrajet2(trajet)

                afficheselectarrivee(waypoints, ari)

            }






            function fermerEditeurWaypoint() {
                const waypointEditor = document.getElementById("waypointEditor");
                waypointEditor.style.display = "none";
                waypointEditor.classList.remove("visible");
            }

            window.fermerEditeurWaypoint = fermerEditeurWaypoint;


            // Gestionnaire pour le bouton "Supprimer" de l editeur 
            document.getElementById('deleteWaypoint').addEventListener('click', function () {
                console.log('fonction de suppression activee')
                nomWP = document.getElementById('wpName').textContent;

                let confirmation = window.confirm('Voulez-vous vraiment supprimer le waypoint ' + nomWP + '?');
                if (confirmation) {
                    //supprimerDuLocalStorage(nomwp);
                    console.log('on tente une suppression dans personalinfos2')
                    //on va tenter une suppression dans personalinfos 
                    typeinfo = 'wp'
                    typeaction = 'delete',
                        valeur = 'rien'
                    nom = nomWP
                    message = modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nom, valeur)
                    console.log(message)
                    // on supprime le waypoint de la variable liste des waypoints pour que ari soit affiche correctement 

                    console.log('liste waypoints avant suppression ')
                    console.log(waypoints)
                    console.log('waypoint a supprimer de la liste ' + nomWP)

                    let index = waypoints.findIndex(waypoint => waypoint[1] === nomWP);
                    if (index !== -1) {
                        waypoints.splice(index, 1);
                        nbWP -= 1;
                    }
                    //waypoints.filter(waypoint => waypoint[1] !== nomWP);
                    console.log('liste waypoints apres suppression ')
                    console.log(waypoints)
                    waypointsnew = waypoints
                    // supprimer le cercle de memoiretrajets
                    trajet = trouvederniertrajet()
                    waypoints = waypointsnew                        // traouve dernier trajet a retabli l ancienne valeur de waypoints      
                    ari = ari.filter(nom => nom !== nomWP);
                    trajet[11] = ari
                    trajet[12] = waypointsnew
                    trajet[13] = 'Mise a jour waypoints et ari '
                    console.log('trajet modifi√© ', +trajet)
                    console.log('username ' + username)
                    console.log('course ' + course)
                    // trajet=[username,course,y0,x0,y0,x0,heuredepart,y1,x1,optionroutage,user_id,ari,waypoints,'maj suite routage' ]
                    updateTrajet(username, course, trajet)

                    // si le waypoint est supprim√© et qu'il est dans ari il faut le supprimer dans ari 


                    // Supprimer le cercle de la carte
                    if (cercleSelectionne) {
                        console.log('Ligne 493 Cercle √† supprimer:', cercleSelectionne);
                        console.log('ligne 495 ' + WpCirclesLayer.hasLayer(cercleSelectionne))
                        WpCirclesLayer.removeLayer(cercleSelectionne);
                        cercleSelectionne = null; // R√©initialiser la s√©lection
                    }

                    console.log('nouvelle valeur de ari apres suppression du WP   : ' + ari)
                    console.log('\nnouvelle valeur du tableau des waypoints apres  suppression du WP  ')
                    console.log(waypointsnew)

                    afficheselectarrivee(waypointsnew, ari)
                    fermerEditeurWaypoint()
                }
            });




            function affichewaypoints2(personalInfosJS) {   // permet d afficher tous les waypoints  
                // Effacer les anciens cercles de la carte
                // R√©cup√©rer uniquement les valeurs des waypoints
                console.log("Valeurs des waypoints  dans affichewaypoints2 :");
                console.log(personalInfosJS.wp)
                if (personalInfosJS.wp) {
                    Object.values(personalInfosJS.wp).forEach(cercleData => {

                        console.log(cercleData);

                        let numero = cercleData[0];
                        let nom = cercleData[1];
                        let lat = cercleData[2];
                        let lon = cercleData[3];
                        let rayon = cercleData[4]; // le rayon recupere est en MN 
                        let couleur = cercleData[5]

                        let cercle = L.circle([lat, lon], {
                            color: 'black',           // Couleur du bord
                            weight: 0.5,
                            fillColor: couleur,      // Couleur de remplissage
                            fillOpacity: 0.5,         // Opacit√© de remplissage
                            radius: rayon * 1000 / 1.852,    // Rayon en Mn converti en m√®tres pour l affichage 
                            draggable: true,          // Rendre le cercle draggable
                            indice: numero
                        });

                        // On lie l ouverture de l'√©diteur de waypoint lorsque le cercle est cliqu√©
                        cercle.on('click', function () {
                            console.log('click detecte sur le cercle ')
                            cercleSelectionne = cercle; // Mettre √† jour le cercle s√©lectionn√©
                            rayon = cercle.getRadius() * 1.852 / 1000                            // le rayon recupere est en m  on le transforme en mN
                            console.log('rayon au moment de louverture de l editeur de cercle ' + rayon)
                            ouvrirEditeurModifWaypoint(cercle, nom, lat, lon, rayon);
                        });

                        // On lie la Gestion des √©v√©nements pendant le d√©placement du cercle
                        cercle.on('drag', function (event) {
                            console.log('click detecte sur le cercle ')
                            console.log('rayon au moment de louverture de l editeur de cercle' + rayon)
                            cercleSelectionne = cercle; // Mettre √† jour le cercle s√©lectionn√©
                            ouvrirEditeurModifWaypoint(cercle, nom, lat, lon, rayon);
                            newLatLng = event.target.getLatLng();
                            newlat = newLatLng.lat
                            newlon = newLatLng.lng
                            document.getElementById('wpLat').textContent = newLatLng.lat.toFixed(4);
                            document.getElementById('wpLon').textContent = newLatLng.lng.toFixed(4);


                        });

                        cercle.bindTooltip(nom).addTo(WpCirclesLayer); //Ajouter le cercle au LayerGroup

                    });    // fin du foreach 

                    WpCirclesLayer.addTo(map);

                }// fin du if
            }   //fin de affichewaypoints2






            //**********************************************************************************************************************************
            //**********************************************************************************************************************************
            //**********    Gestion de l editeur de routes                                          ********************************************
            //**********************************************************************************************************************************

            var routageLayer = L.layerGroup().addTo(map);
            var polylines = {}; // Objet pour stocker les polylines
            let routes = [];  // Tableau global contenant toutes les routes



            function getRandomColor() {
                return "#" + Math.floor(Math.random() * 16777215).toString(16); // G√©n√®re une couleur hexad√©cimale al√©atoire
            }



            window.EditeurRoutes = () => { ouvrirEditeurRoutes() }
            function ouvrirEditeurRoutes()
            // Fonction pour ouvrir l'√©diteur de waypoint
            {
                console.log(' Demande affichage ouvrirEditeurRoutes l 1941 ')
                const RoutesEditor = document.getElementById("RoutesEditor");
                RoutesEditor.style.display = "block";
                document.getElementById("RoutesEditor").classList.add("visible");
            };




            window.fermerEditeurRoutes = () => {
                const RoutesEditor = document.getElementById("RoutesEditor");
                RoutesEditor.style.display = "none";
                RoutesEditor.classList.remove("visible");
            }


            window.sauveroute = async () => {
                console.log('On est dans sauveroute');
                try {
                    await sauveRouteServeur2();  // Attente de la sauvegarde
                    mettreAJourTableau();  // Mise √† jour de l'affichage apr√®s la sauvegarde
                } catch (error) {
                    console.error('Erreur lors de la sauvegarde : ', error);
                    alert("Erreur lors de la sauvegarde : " + error.message);
                }
            };



            window.afficherroute = function (i) {
                if (i < 0 || i >= routes.length) {
                    console.error("Index invalide :", i);
                    return;
                }

                let route = routes[i];

                if (!route.layer) { // Si la polyline n'existe pas encore
                    console.log(`Affichage de la route : ${route.nom}`);

                    let polylineLeaflet = L.polyline(route.polyline, { color: route.couleur, weight: 1 }).addTo(map);
                    routes[i].layer = polylineLeaflet; // Stocke la r√©f√©rence dans routes[i]
                } else if (!map.hasLayer(route.layer)) {
                    map.addLayer(route.layer);
                }
            };




            window.effacerroute = function (i) {
                if (i < 0 || i >= routes.length) {
                    console.error("Index invalide :", i);
                    return;
                }

                let route = routes[i];
                console.log(`Effacement de la route : ${route.nom}`);

                if (route.layer && map.hasLayer(route.layer)) {
                    map.removeLayer(route.layer);
                    console.log(`Route ${route.nom} supprim√©e de la carte`);
                } else {
                    console.warn(`La route ${route.nom} n'est pas affich√©e ou n'existe pas`);
                }
            };



            window.exporterroute = function (i) {
                exporterroute(i)
            }


            window.supprimerroute = function (i) {
                let nom = routes[i].nom;
                console.log('Username:', username);
                console.log('Course:', course);
                console.log('Nom du routage √† supprimer:', nom);
                supprimerroute(i);
            };







            function genererNomRoutage() {
                let now = new Date();
                let jour = String(now.getDate()).padStart(2, '0');
                let mois = String(now.getMonth() + 1).padStart(2, '0'); // Les mois commencent √† 0
                let heure = String(now.getHours()).padStart(2, '0');
                let minute = String(now.getMinutes()).padStart(2, '0');
                return `Routage ${jour}/${mois} ${heure}:${minute}`;
            }





            async function sauveRouteServeur2() {
                typeinfo = 'routage';
                typeaction = 'insert';
                console.log('Sauvegarde de la route sur le serveur dans personalinfos2');
                nbRoutes = routes.length
                let color = colorhex[nbRoutes % colorhex.length];
                console.log(color)

                let nomRoutage = document.getElementById('nomRoutage').value;

                // V√©rification des valeurs avant de sauvegarder
                if (!nomRoutage || !eta || !dureeparcours || !polyglobal) {
                    alert("Donn√©es incompl√®tes pour sauvegarder la route.");
                    return;
                }

                // Cr√©ation de l'objet JSON pour la nouvelle route
                let nouvelleRoute = {
                    nom: nomRoutage,
                    eta: eta,
                    duree: dureeparcours,
                    couleur: color,
                    polyline: polyglobal
                };

                try {
                    let message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nomRoutage, JSON.stringify(nouvelleRoute));
                    console.log('Sauvegarde r√©ussie : ', message);
                    alert('Route sauvegard√©e avec succ√®s !');

                    // ‚úÖ Ajout de la nouvelle route √† `routes` localement
                    routes.push(nouvelleRoute);

                    // ‚úÖ Mise √† jour imm√©diate de l'affichage
                    mettreAJourTableau();
                } catch (error) {
                    console.error('Erreur lors de la sauvegarde : ', error);
                    alert('√âchec de la sauvegarde : ' + error.message);
                }
            }





            function mettreAJourTableau() {
                console.log('Mise √† jour du tableau des routes');

                let texte = `<table id="tableRoutes">
                    <tr>
                        <th class="colDouble">Nom</th>
                        <th>ETA</th>
                        <th>Dur√©e</th>
                        <th>Couleur</th>
                        <th colspan="4">Actions</th>
                    </tr>`;

                for (let i = 0; i < routes.length; i++) {
                    let route = routes[i];
                    let couleur = colorhex[i % colorhex.length]; // S√©lection avec modulo

                    texte += `
        <tr>
            <td class="colDouble">${route.nom}</td>
            <td>${route.eta}</td>
            <td>${formatDuree(route.duree)}</td>            
            <td><input type="color" value="${route.couleur}" oninput="changerCouleurRoute(${i}, this.value)"></td>  
            <td><button onclick="afficherroute(${i})">Afficher</button></td>
            <td><button onclick="effacerroute(${i})">Masquer</button></td>
            <td><button onclick="supprimerroute(${i})">Supprimer</button></td>
            <td><button onclick="exporterroute(${i})">Export GPX</button></td>
        </tr>`;
                }

                texte += `</table>`;
                document.getElementById('tableroutages').innerHTML = texte;
            }



            window.changerCouleurRoute = async function (i, nouvelleCouleur) {
                console.log(`Changement de couleur pour la route ${routes[i].nom} -> ${nouvelleCouleur}`);

                // Mise √† jour de la couleur dans `routes`
                routes[i].couleur = nouvelleCouleur;

                // üü¢ V√©rifier si la polyline est affich√©e et mettre √† jour imm√©diatement
                if (routes[i].layer && map.hasLayer(routes[i].layer)) {
                    routes[i].layer.setStyle({ color: nouvelleCouleur });
                    console.log(`Couleur de la route ${routes[i].nom} mise √† jour sur la carte.`);
                }

                // üü¢ Sauvegarde de la modification sur le serveur
                try {
                    let typeinfo = 'routage';
                    let typeaction = 'modify';
                    let nomRoutage = routes[i].nom;

                    let nouvelleRoute = {
                        nom: nomRoutage,
                        eta: routes[i].eta,
                        duree: routes[i].duree,
                        couleur: nouvelleCouleur,
                        polyline: routes[i].polyline
                    };

                    let message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nomRoutage, JSON.stringify(nouvelleRoute));
                    console.log(`Mise √† jour r√©ussie : ${message}`);
                } catch (error) {
                    console.error('Erreur lors de la mise √† jour de la couleur : ', error);
                    alert('√âchec de la mise √† jour de la couleur.');
                }
            };












            function recupereRoutes(personalInfosJS) {
                routes = [];  // R√©initialisation avant de charger de nouvelles routes

                if (personalInfosJS.routage) {
                    for (const key in personalInfosJS.routage) {
                        if (personalInfosJS.routage.hasOwnProperty(key)) {
                            const routage = personalInfosJS.routage[key];
                            //console.log ('ligne 2179 '+routage.polyline)   (un par routage)
                            routes.push({
                                nom: routage.nom,
                                eta: routage.eta,
                                duree: routage.duree,
                                couleur: routage.couleur,
                                polyline: routage.polyline
                            });
                        }
                    }
                }
                console.log("Routes charg√©es :", routes);
                mettreAJourTableau(); // ‚úÖ Mise √† jour de l'affichage avec les donn√©es charg√©es
            }







            async function supprimerroute(i) {

                if (i < 0 || i >= routes.length) {
                    console.error("Index invalide :", i);
                    return;
                }

                let nom = routes[i].nom;
                console.log(`Suppression de la route ${nom} sur le serveur dans personalinfos2`);

                try {
                    // 1Ô∏è‚É£ **Supprime la route sur le serveur**
                    let message = await modifpersonalinfos(username, user_id, course, 'routage', 'delete', nom, ' ');
                    console.log("R√©ponse du serveur:", message);

                    // 2Ô∏è‚É£ **Supprime la polyline de la carte si elle existe**
                    if (polylines[nom]) {
                        map.removeLayer(polylines[nom]);
                        delete polylines[nom];
                        console.log(`Polyline ${nom} supprim√©e`);
                    }

                    // 3Ô∏è‚É£ **Supprime la route du tableau local**
                    routes.splice(i, 1);

                    // 4Ô∏è‚É£ **Met √† jour l'affichage**
                    mettreAJourTableau();
                    console.log(`Route ${nom} supprim√©e localement`);

                } catch (error) {
                    console.error("Erreur lors de la suppression :", error);
                    alert("√âchec de la suppression : " + error.message);
                }
            }



            async function exporterroute(i) {
                let route = routes[i];
                let points = route.polyline[0].flat()
                //    console.log (points)
                nom = route.nom
                exportGPX(points, nom);

            }



            //**********************************************************************************************************************************
            //**********    Affichage de la Flotte                                                  ********************************************
            //**********************************************************************************************************************************



            async function afficheFlotte() {

                fleetMarkers.clearLayers()
                let url = `${serveur}/rechercheflotte?id_user=${user_id}&course=${course}`;

                let response = await fetch(url);
                if (!response.ok) throw new Error('Probl√®me dans rechercheflotte ' + response.statusText);

                let data = await response.json();
                console.log('data.fleetinfos' + data.fleetinfos)

                let flotte = JSON.parse(data.fleetinfos);
                // console.log (' teamnames dans afficheflotte '+teamnames )

                flotte.forEach(boat => {
                    var twd = computeTWD(boat[4], -boat[7])
                    var couleur;



                    if (boat[1] == "normal") couleur = "grey";
                    else if (boat[1] == "top") couleur = "#ffd700";
                    else if (boat[1] == "friend") couleur = "#32cd32";
                    else if (boat[1] == "sponsor") couleur = "#4169e1";
                    else if (boat[1] == "real") couleur = "#87ceeb";
                    else couleur = "white";
                    if (teamnames.includes(boat[0])) { couleur = 'purple' };


                    if (boat[0] == username) {
                        couleur = "blue";

                        fleche4([boat[2], boat[3]], boat[4], 0.05, 'blue', fleetMarkers);
                        fleche4([boat[2], boat[3]], twd + 180, 0.10, 'green', fleetMarkers);
                        fleche4([boat[2], boat[3]], twd + 90, 0.15, 'green', fleetMarkers);
                        fleche4([boat[2], boat[3]], twd - 90, 0.15, 'green', fleetMarkers);


                    }



                    addBoatMarker(fleetMarkers, boat[0], boat[2], boat[3], {
                        color: couleur,
                        heading: boat[4],
                        speed: boat[5],
                        twd: twd,
                        //vmg: boat[6],    // si tu veux l‚Äôafficher plus tard
                        twa: boat[7],
                        tws: boat[6],
                        sail: boat[8]

                    })

                });






                fleetMarkers.addTo(map)





            }






            //**********************************************************************************************************************************
            //**********    Gestion des Zones exclusion persos                                                  ********************************************
            //**********************************************************************************************************************************

            let zonePoints = [];
            let polygon = null;
            let isDrawing = false; // Indique si le trac√© est actif


            window.EditeurExclusions = () => { ouvrirEditeurExclusions() }
            function ouvrirEditeurExclusions()      // Fonction pour ouvrir l'√©diteur de waypoint
            {
                const exEditor = document.getElementById("exEditor");
                exEditor.style.display = "block";
                mettreAJourListeZones() // on ajoute la liste des zones  dans les zones existates
                document.getElementById("exEditor").classList.add("visible");
            };


            window.startDrawing = () => {
                isDrawing = true;
                zonePoints = [];
                if (polygon) {
                    map.removeLayer(polygon);
                    polygon = null;
                }
                alert('Cliquez sur la carte pour ajouter des points √† la zone.');
            };



            // Ajout d'un listener sur les clics pour d√©finir les points
            map.on('click', (e) => {
                if (!isDrawing) return; // Ignore les clics si le trac√© est termin√©
                const { lat, lng } = e.latlng;
                zonePoints.push([lat, lng]);
                if (polygon) {
                    polygon.setLatLngs(zonePoints);
                } else {
                    polygon = L.polygon(zonePoints, { color: 'blue', weight: .8, fillcolor: 'blue', opacity: 0.2 }).addTo(map);
                }
            });



            window.finishDrawing = () => {
                if (zonePoints.length > 2) {
                    polygon.setLatLngs([...zonePoints, zonePoints[0]]); // Fermer la zone
                    isDrawing = false; // D√©sactiver le trac√©
                    zonePoints.push(zonePoints[0]);
                    createZone(zonePoints)
                    alert('Trac√© termin√©.');
                } else {
                    alert('Vous devez s√©lectionner au moins trois points pour cr√©er une zone.');
                }
            };



            window.deleteDrawing = () => {
                if (polygon) {
                    map.removeLayer(polygon); // Supprimer le polygone de la carte
                    polygon = null; // R√©initialiser la r√©f√©rence
                    zonePoints = []; // Vider les points
                    isDrawing = false; // D√©sactiver le trac√©
                } else {
                    alert('Aucun trac√© √† supprimer.');
                }

            }



            window.fermerEx = () => {
                console.log('Bouton supprimer la Zone declench√©')
                nomZone = document.getElementById('dynamicSelect').value
                console.log('Bouton supprimer la Zone declench√© avec nom de zone ' + nomZone)
                deleteZone(username, course, nomZone)
            }


            window.fermerEditeurEx = () => {
                const exEditor = document.getElementById("exEditor");
                exEditor.style.display = "none";
                exEditor.classList.remove("visible");
            }



            async function createZone(zonepoints) {
                // sauve la zone danspersonalinfos2 

                nomZone = document.getElementById('nomNewZone').value
                zonePointsStr = JSON.stringify(zonepoints)
                // console.log('sauvegarde des points sur le serveur ')
                // console.log('zonepoints')
                // console.log('Nom de la Zone d exclusions : ' + nomZone)
                // conso.log('points ' + zonepoints)

                // on va sauver dans personalinfos2
                typeinfo = 'exclusions'
                typeaction = 'insert',
                    nom = nomZone
                valeur = zonePoints    // au lieu de zonePointsStr
                console.log(` Pour ${username} sur ${course} Action ${typeaction} de ${typeinfo} nom  ${nomZone} valeur  ${valeur} `)
                message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nom, valeur)
                console.log(message)


                let polygone = L.polygon(zonepoints)
                    .setStyle({ color: 'black', fillColor: 'blue', weight: 0.5, fillOpacity: 0.2 })
                    .bindTooltip(nomZone, { permanent: false, direction: "center", className: "zone-tooltip" })
                    .on("click", () => ouvrirEditeurExclusions(nomZone, zonepoints)) // üîπ Ouvrir l'√©diteur sur clic
                    .addTo(layerExclusions);

                listeZones.push(nomZone);

                console.log(' ligne 2425 Listezones apres ajout  ' + listeZones)
                zonesPolygones[nomZone] = polygone;
                exclusionsMap.set(nomZone, polygone);
                mettreAJourListeZones()
            }







            async function deleteZone(username, course, nomZone) {
                // Supprimer une zone (mise √† jour carte + liste)
                console.log("Suppression de la zone :", nomZone);

                // Suppression dans la base
                let typeinfo = 'exclusions';
                let typeaction = 'delete';
                let nouvelleZone = '';

                let message = await modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nomZone, nouvelleZone);

                // Si la suppression est confirm√©e, retirer de la carte et mettre √† jour la liste
                // if (message.success) { // üîπ Supposons que `message.success` indique la r√©ussite
                if (zonesPolygones[nomZone]) {
                    layerExclusions.removeLayer(zonesPolygones[nomZone]); // üîπ Supprimer de la carte
                    delete zonesPolygones[nomZone]; // üîπ Supprimer du stockage des polygones
                }
                listeZones = listeZones.filter(zone => zone !== nomZone); // üîπ Mise √† jour de listeZones
                console.log("Zones restantes :", listeZones);
                //  }

                mettreAJourListeZones()
            }




            function mettreAJourListeZones() {
                // let listeZones = Array.from(exclusionsMap.keys());
                console.log('ligne 2417 listeZones' + listeZones)

                let texte = '';
                for (let i = 0; i < listeZones.length; i++) {
                    texte += '<option value="' + listeZones[i] + '">' + listeZones[i] + '</option>';
                }
                document.getElementById('dynamicSelect').innerHTML = texte;
            }



            //**********************************************************************************************************************************
            //**********    Gestion de la creation de barrieres                                     ********************************************
            //**********************************************************************************************************************************


            // === Variables globales ===
            let isDrawingBa = false;
            let currentPoints = [];
            let currentPolyline = null;
            let barrieres = {}; // { nom: [[lat, lon], [lat, lon]] }
            let barrieresPolylines = {};
            let listeBarrieres = [];



            // === Ouvrir l'√©diteur ===
            window.EditeurBarrieres = () => {
                document.getElementById("baEditor").style.display = "block";
                updateBarrieresSelect();
                document.getElementById("baEditor").classList.add("visible");
            };

            // === Met √† jour le select des barri√®res existantes ===
            function updateBarrieresSelect() {
                const select = document.getElementById("BarrieresSelect");
                select.innerHTML = "";
                listeBarrieres.forEach(nom => {
                    const option = document.createElement("option");
                    option.value = nom;
                    option.textContent = nom;
                    select.appendChild(option);
                });
            }


            // === Commencer le dessin d'une barri√®re ===
            window.startDrawingBa = () => {
                const nom = document.getElementById("nomNewBarriere").value.trim();
                if (!nom) return alert("Donnez un nom √† la barri√®re.");

                isDrawingBa = true;
                currentPoints = [];
                if (currentPolyline) {
                    layerBarrieres.removeLayer(currentPolyline);
                    currentPolyline = null;
                }
                alert("Cliquez pour ajouter deux points √† la barri√®re.");
            };



            // === Clic sur la carte pour dessiner ===
            map.on('click', function (e) {
                if (!isDrawingBa) return;
                console.log('Click pour barriere')
                currentPoints.push([e.latlng.lat, e.latlng.lng]);
                console.log('CurrentPoints : ' + currentPoints)

                if (currentPoints.length === 2) {
                    if (currentPolyline) layerBarrieres.removeLayer(currentPolyline);

                    currentPolyline = L.polyline(currentPoints, { color: 'red' }).addTo(layerBarrieres);
                    currentPolyline.editing?.enable?.(); // pour activer l'√©dition si Leaflet.Editable ou Leaflet.Draw est int√©gr√©
                    layerBarrieres.addTo(map)

                }
            });


            // === Finaliser le dessin ===
            window.finishDrawingBa = async () => {
                const nom = document.getElementById("nomNewBarriere").value.trim();
                if (currentPoints.length !== 2 || !nom) {
                    alert("D√©finissez deux points et donnez un nom.");
                    return;
                }


                // Enregistre localement
                barrieres[nom] = currentPoints.slice();
                listeBarrieres.push(nom);
                barrieresPolylines[nom] = currentPolyline;
                currentPolyline.bindTooltip(nom, { permanent: false, direction: 'center' });

                // tracer la barriere 

                updateBarrieresSelect();

                // Enregistre dans la base
                await modifpersonalinfos(username, user_id, course, 'barrieres', 'insert', nom, currentPoints);

                // R√©initialise
                isDrawingBa = false;
                currentPoints = [];
                currentPolyline = null;
                alert("Barri√®re sauvegard√©e.");
            };

            // === Annuler le dessin en cours ===
            window.deleteDrawingBa = () => {
                isDrawingBa = false;
                currentPoints = [];
                if (currentPolyline) {
                    layerBarrieres.removeLayer(currentPolyline);
                    currentPolyline = null;
                }
                alert("Barri√®re annul√©e.");
            };

            // === Supprimer une barri√®re existante ===
            window.fermerBa = async () => {
                const select = document.getElementById("BarrieresSelect");
                const nom = select.value;
                if (!nom) return;

                delete barrieres[nom];
                listeBarrieres = listeBarrieres.filter(n => n !== nom);

                if (barrieresPolylines[nom]) {
                    layerBarrieres.removeLayer(barrieresPolylines[nom]);
                    delete barrieresPolylines[nom];
                }

                await modifpersonalinfos(username, user_id, course, 'barrieres', 'delete', nom, '');
                updateBarrieresSelect();
                alert("Barri√®re supprim√©e.");
            };




            // === Afficher les barri√®res au chargement ===
            function afficheBarrieres(personalInfosJS) {

                console.log('On est dans affichebarrieres ')
                console.log (' personalInfosJS ' +personalInfosJS)
                layerBarrieres.clearLayers();
                barrieresPolylines = {};
                listeBarrieres = [];
               
                if (!personalInfosJS.barrieres) return;

                for (let nom in personalInfosJS.barrieres) {
                    const points = personalInfosJS.barrieres[nom];
                    const polyline = L.polyline(points, { color: 'red' }).addTo(layerBarrieres);
                    polyline.bindTooltip(nom, { permanent: false, direction: 'center' });

                    barrieres[nom] = points;
                    barrieresPolylines[nom] = polyline;
                    listeBarrieres.push(nom);
                }

                updateBarrieresSelect();
                layerBarrieres.addTo(map)
            }






            // === R√©initialiser compl√®tement les barri√®res (ex. changement de course) ===
            function clearAllBarrieres() {
                layerBarrieres.clearLayers();
                barrieres = {};
                barrieresPolylines = {};
                listeBarrieres = [];
                updateBarrieresSelect();
            }

            // === Fermer l'editeur de barrieres ===
            window.fermerEditeurBa = () => {
                const baEditor = document.getElementById("baEditor");
                baEditor.style.display = "none";
                baEditor.classList.remove("visible");

            }






            //***************************************************************************************************************
            //********  Gestion boite jaune                                                    ******************************
            //***************************************************************************************************************
            //Dupliquer progsvr
            // affichertableau
            //ajouterligne
            //supprimerligne
            // initialiser les gestionnaires ajouter et supprimer





            var dupliquerprogsvr = document.getElementById('dupliquerprogsvr')
            dupliquerprogsvr.addEventListener("click", function (evt) {
                console.log('Bouton de duplication cliqu√©')
                console.log('user_id ' + user_id)
                console.log('course ' + course)
                //programmationsvr=chercheprogsserveur(user_id,course)
                console.log('programmationsvr issues de la demande de duplication')
                console.log(programmationsvr)
                programmationsvrjaunes = [].concat(programmationsvr)
                afficherTableau3(programmationsvr)
                let voileautojaunes = document.getElementById('voileautojaunes')

                voilesauto = voileautojaunes.checked
                calculeroute(user_id, course, programmationsvr, voilesauto)
            });







            function afficherTableau3(progra) {
                let texte = '';
                texte += `<div class='progsvr' > <span class= 'col120' > Progs Jaunes </span>
    <span class= 'col30' ><input type='checkbox' id='showprogsvrjaunes' name='showprogsvrjaunes'  checked    /></span>
    <span class= 'col120' >Voiles Auto jaunes</span>
    <span class= 'col30' ><input type='checkbox' id='voileautojaunes' name='voileautojaunes'  checked    /></span>
    </div>`

                if (!Array.isArray(progra) || progra.length === 0) {
                    // Si programmationsvr n'est pas un tableau ou est vide, on affiche un message ou on ne fait rien
                    texte = 'Aucune donn√©e disponible.';
                }
                else {
                    progra.forEach((ligne, i) => {
                        let [unixTime, option, valeur] = ligne;
                        //console.log (ligne)
                        // Recalculer heure et minutes √† partir du timestamp Unix
                        const date = new Date(unixTime * 1000); // Conversion en millisecondes
                        const heure = date.getHours(); // Heure locale
                        const mn = date.getMinutes(); // Minutes locales

                        // D√©terminer la classe et l'option s√©lectionn√©e
                        let classcolor, selected;
                        if (option === 1) { classcolor = 'green'; selected = 0; }
                        if (option === -1) { classcolor = 'red'; selected = 1; }
                        if (option === 0) { classcolor = 'purple'; selected = 2; }

                        // Construire la ligne HTML
                        texte += `
                A <input class="classinput" id="heureprog${i}" type="number" min="0" max="24" step="1" value="${heure}">
                H <input class="classinput" id="mnprog${i}" type="number" min="0" max="60" step="1" value="${mn}">
                <span class="col20"></span>
                <select id="twacap${i}" class="black">
                    <option value="Twa+" ${selected === 0 ? "selected" : ""}>Twa+</option>
                    <option value="Twa-" ${selected === 1 ? "selected" : ""}>Twa-</option>
                    <option value="Cap" ${selected === 2 ? "selected" : ""}>Cap</option>
                </select>
                <input type="number" id="valtwacap${i}" class="${classcolor}" min="0" max="${selected === 2 ? 360 : 180}" step="1" value="${Math.abs(valeur)}">
                <span class="col20"></span>
                <button class="black12 add-row" data-index="${i}">+</button>
                <button class="black12 remove-row" data-index="${i}">-</button>
                <br>
            `;
                    });

                    // Ins√©rer le tableau dans un conteneur HTML (par exemple, une div avec id="boitejaune")
                    document.getElementById('boitejaune').innerHTML = texte;
                    const showprogsvrjaunes = document.getElementById('showprogsvrjaunes')
                    showprogsvrjaunes.addEventListener('change', toggleshowprogsLayerJaune())


                    //gestionnaire d 'evenements pour changement voileauto 
                    document.getElementById('voileautojaunes').addEventListener('change', function () {
                        voilesauto = voileautojaunes.checked
                        calculeroute(user_id, course, progra, voilesauto);
                    });
                }
            }





            // Fonction pour ajouter une ligne au tableau en dessous de la ligne selectionn√©e 
            function ajouterLigneT3(index) {
                // D√©terminer un timestamp Unix pour une nouvelle ligne (par exemple, l'heure actuelle)
                console.log('programmationsvrjaunes')
                console.log(programmationsvrjaunes)
                console.log(programmationsvrjaunes[0])
                let timeplus60 = programmationsvrjaunes[index][0] + 600
                let optionplus = programmationsvrjaunes[index][1]
                let valeurplus = programmationsvrjaunes[index][2]
                const nowUnix = Math.floor(Date.now() / 1000); // Timestamp Unix en secondes
                //programmationsvrjaunes.splice(index + 1, 0, [nowUnix, 0, 0]);
                programmationsvrjaunes.splice(index + 1, 0, [timeplus60, optionplus, valeurplus]);
                // Rafra√Æchir l'affichage
                afficherTableau3(programmationsvrjaunes);
            }





            // Fonction pour supprimer une ligne du tableau
            function supprimerLigneT3(index) {
                console.log('Bouton de suppression  cliqu√©')
                if (programmationsvrjaunes.length >= 1) {
                    programmationsvrjaunes.splice(index, 1); // Supprime la ligne √† l'index donn√©

                    // Rafra√Æchir l'affichage
                    console.log('index de la ligne a supprimer ' + index)
                    console.log('programmationsvrjaunes apres suppression ')
                    console.log(programmationsvrjaunes)
                    afficherTableau3(programmationsvrjaunes);
                } else {
                    alert("Vous ne pouvez pas supprimer la derni√®re ligne.");
                }
            }




            // Gestionnaire d'√©v√©nements pour les boutons Ajouter et Supprimer
            function initialiserEvenementsT3() {
                document.getElementById('boitejaune').addEventListener('click', (event) => {
                    if (event.target.classList.contains('add-row')) {
                        const index = parseInt(event.target.dataset.index, 10);
                        ajouterLigneT3(index);
                    } else if (event.target.classList.contains('remove-row')) {
                        const index = parseInt(event.target.dataset.index, 10);
                        supprimerLigneT3(index);
                    }
                });
            }



            function recupererDonnees() {
                console.log('on est dans recupererdonnees')
                // R√©cup√©rer les donn√©es des inputs actuels
                donneesprog = donneesprog.map((_, i) => {
                    const twacap = document.getElementById(`twacap${i}`).value;
                    const valeur = parseInt(document.getElementById(`valtwacap${i}`).value);
                    const heure = parseInt(document.getElementById(`heureprog${i}`).value);
                    const mn = parseInt(document.getElementById(`mnprog${i}`).value);
                    let option;
                    if (twacap === "Twa+") option = 1;
                    else if (twacap === "Twa-") option = 1;
                    else option = 0;
                    const valeurFinale = twacap === "Twa-" ? -valeur : valeur;
                    return [heure, mn, option, valeurFinale];

                });
                console.log(" Ligne 928 Donn√©es r√©cup√©r√©es******************************************** :", donneesprog);
                return donneesprog;
            }



            initialiserEvenementsT3()




            var boitejaune = document.getElementById('boitejaune')
            boitejaune.addEventListener("change", function (evt) {
                console.log('changement dans boite jaune')
                if (evt.target.matches('[id^="heureprog"], [id^="mnprog"], [id^="twacap"], [id^="valtwacap"]')) {
                    let timer = null; // Timer pour le d√©clenchement diff√©r√©
                    clearTimeout(timer); // Annule le timer existant
                    timer = setTimeout(() => {
                        const jourEnCours = Math.floor(new Date().setHours(0, 0, 0, 0) / 1000); // Timestamp Unix pour minuit du jour en cours
                        const programmations = []; // Tableau pour stocker les donn√©es transform√©es
                        const lignes = document.querySelectorAll('.classinput[id^="heureprog"]'); // S√©lectionne les champs de saisie des heures
                        lignes.forEach((ligne, i) => {
                            const heure = parseInt(document.getElementById(`heureprog${i}`).value);
                            const minutes = parseInt(document.getElementById(`mnprog${i}`).value);
                            const option = document.getElementById(`twacap${i}`).value;
                            const valeur = parseFloat(document.getElementById(`valtwacap${i}`).value);
                            const optionCode = option === 'Twa+' ? 1 : option === 'Twa-' ? -1 : 0; // Transformer l'option en format attendu
                            const valeurCorrigee = optionCode === 0 ? valeur : valeur;      //* optioncode;
                            let unixTime = jourEnCours + heure * 3600 + minutes * 60;            // Calcul du timestamp Unix


                            if (i >= 1 && unixTime < programmations[i - 1][0]) { console.log('On est dans le jour +1'); unixTime += 86400 }
                            programmations[i] = [unixTime, optionCode, valeurCorrigee]
                        })
                        console.log('programmations : ')
                        console.log(programmations)




                        let voileautojaunes = document.getElementById('voileautojaunes')
                        voilesauto = voileautojaunes.checked
                        console.log('\n Ligne 2550 Voileautojaune  ' + voilesauto)

                        calculeroute(user_id, course, programmations, voilesauto) // on envoie sur l appele ajax 
                    }, 1000); // D√©lai de 1 seconde
                }




                if (evt.target.matches('[id^="show"]')) {
                    console.log('changement detecte sur  check boite jaune')
                    if (showprogsvrjaunes.checked) { progsvrLayerJaune.addTo(map); } // Ajouter le layer √† la carte   


                    else { map.removeLayer(progsvrLayerJaune); }// Retirer le layer de la carte

                }
            });



            document.getElementById('voilesautovr').addEventListener('click', function (event) {
                event.preventDefault();
            });

            document.getElementById('twaauto').addEventListener('click', function (event) {
                event.preventDefault();
            });



            // gestionnaire d 'evenements pour changement voileauto 
            // document.getElementById('voileautojaunes').addEventListener('change', function() {
            //     voilesauto=voileautojaunes.checked 
            //     calculeroute(user_id,course,programmations,voilesauto);
            //      });

            // async function calculeroute(user_id,course,programmations)
            // {

            // // avant d envoyer la demande de calcul au serveur on uniformise la premiere date jaune avec les programmations rouges

            // console.log(' ligne 706 heure de la premiere programmation jaune ' + hmns.format(programmations[0][0]*1000))
            // console.log(' ligne 706 heure de la premiere programmation rouge ' + hmns.format(heurePremiereProg*1000))


            // programmations[0][0]=heurePremiereProg
            // const progs5 = JSON.stringify(programmations);        // pour envoi par url 

            // url=serveur+"/calculroute?username="+username+"&user_id="+user_id+"&course="+course+"&programmations="+progs5
            //         let response = await fetch(url);            
            //         if (!response.ok) { throw new Error('Probleme dans calculroute ' + response.statusText);    }
            //         let data = await response.json();
            //         polylineprog=data.polylineprog
            //         afficheligneprogsjaunes(polylineprog)// il n y a plus qu a tracer 
            // }





            //***************************************************************************************************************
            //********  Exemples gestion personalinfos2                                  ******************************
            //***************************************************************************************************************




            // console.log ('infos   par personalinfos 2 '+infos)
            // infos=JSON.parse(infos)
            // waypoints2=infos['wp']
            // console.log ('waypoints2  '+waypoints2 ['wp1'])

            // //on va tenter une insertion  de personalinfos 

            //on va tenter une suppression dans personalinfos 
            // typeinfo='wp'
            // nom='wp1'
            // typeaction ='delete',
            // valeur='rien'
            // message=await modifpersonalinfos(username,course,typeinfo,typeaction,nom,valeur)
            // console.log(message)


            // typeinfo='wp'
            // typeaction ='insert',
            // nom='wp1'
            // valeur=JSON.stringify([1, 48.3753, -7.46093, 'WP1', 20, 'yellow'])
            // message=await modifpersonalinfos(username,course,typeinfo,typeaction,nom,valeur)
            // console.log(message)

            //on va tenter une suppression dans personalinfos 
            // typeinfo='wp'
            // typeaction ='delete',
            // valeur='rien'
            // message=await modifpersonalinfos(username,course,typeinfo,typeaction,nom,valeur)
            // console.log(message)


            // //on va tenter une modification dans personalinfos 
            // typeinfo='wp'
            // nom='wp1'
            // typeaction ='modify',
            // valeur=JSON.stringify([1,"WP1", 48.3753, -7.46093,  20, "yellow"])

            // message=await modifpersonalinfos(username,course,typeinfo,typeaction,nom,valeur)
            // console.log(message)
            // let data = await recherchepersonalinfos(username,course)
            // console.log ('Nouvelles valeurs infos   par personalinfos 2 '+infos)











            //***************************************************************************************************************
            //********  Programme proprement dit main                                   ******************************
            //***************************************************************************************************************

            async function maindash(posStart) {

                // console.log ('on est dans maindash')
                // console.log (JSON.stringify(posStart))
                username = posStart.username
                teamname = posStart.teamname
                race = posStart.race
                bateau=posStart.bateau
                leg = posStart.leg
                tws = posStart.tws
                twd = posStart.twd
                twa = posStart.twa
                y0 = posStart.lat
                x0 = posStart.lon
                t0 = posStart.t0
                user_id = posStart.user_id
                legStartDate = posStart.legStartDate
                last_seen_rank = posStart.last_seen_rank
                state = posStart.state
                speed = posStart.speed
                twaAuto = posStart.twaAuto
                sail = posStart.sail
                polar_id = posStart.polar_id
                stamina = posStart.stamina
                lastCalcDate = posStart.lastCalcDate
                gateGroupCounters = posStart.gateGroupCounters
                heading = posStart.heading
                rank = posStart.rank
                tsLastAction = posStart.tsLastAction
                t0 = posStart.t0
                course = race + '.' + leg

                //on initialise un trajet en localstorage



            }


            // async function mainelse(){

            // console.log ('On est dans le main pour un autre bateau ')

            // }






            async function main() {
                // recupere toutes les infos et affiche mais ne fait rien     
                // On commence par aller chercher sur Local storage la derni√®re course enregistr√©e 
                majgrib()

                tabNameCourses = await chercheracesinfos() // independant de tout  deja dans initialize mais pas forcement deja charg√© 

                if (sourceinfos != 'dash') { trajet = trouvederniertrajet() }   // trouve le dernier trajet pour le charger
                else {
                    await maindash(posStart)
                    username = posStart.username
                    teamname = posStart.teamname
                    isMe     = posStart.isMe
                    race = posStart.race
                    leg = posStart.leg
                    course = race + '.' + leg
                    y0vr = posStart['lat']               // Derni√®re position VR 
                    x0vr = posStart['lon']
                    t0 = posStart['lastCalcDate']      // dernier temps de calcul en s               
                    // Liste des waypoints a parcourir 

                    console.log('bateau ' + bateau)

                    if (isMe == 'yes') {
                        //console.log (' Avant recherche trajet complet username '+username+' course '+course )

                        trajet = trouvetrajet(username, course)
                        console.log('Trajet Avant modification avec les derni√®res donn√©√©es du Dash  popur ' + username + ' course ' + course)
                        console.log(trajet)
                        // on remet √† jour les derni√®res valeurs communiqu√©es  
                        ari       = trajet[11]
                        waypoints = trajet[12]                    // liste globale des waypoints 
                        
                        console.log('Heure derni√®re position ' + intlhmn.format((t0)))
                    }

                //     if (bateau == 'else') {
                //         console.log('On est dans le cas else d un autre concurrent')
                //         trajet = trouvederniertrajet()
                //         // traouve dernier trajet a retabli l ancienne valeur de waypoints  
                //          username = posStart.username
                //    // teamname = posStart.teamname
                //    // sourcedash = posStart.source
                //     // race = posStart.race
                //     // leg = posStart.leg
                //     // course = race + '.' + leg
                //     y0vr = posStart['lat']               // Derni√®re position VR 
                //     x0vr = posStart['lon']
                //     t0 = posStart['lastCalcDate']      // dernier temps de calcul en s   
                        
                        

                //         ari = trajet[11]
                //         waypoints = trajet[12]
                //     }


                }





                console.log('Valeurs utilis√©es par Index dans main ')
                console.log('username ' + username + ' y0vr ' + y0vr + ' x0vr ' + x0vr + ' t0 ' + t0 + ' ari ' + ari)

                map.panTo([y0vr, x0vr])               // on centre la carte normalement on a les coordonnees par trouvederniertrajet                             

                leginfos = await chercheleginfos(course)
                afficheleginfos(leginfos)
                console.log(`leginfos recuperees pour la course par chercheleginfos ${course} \n*******************\n ${leginfos}`)

                carte = await chargecartemaps2(y0vr, x0vr)
                affichecarte(carte)                                       // affiche la carte locale pas forcement necessaire 

                var teamnames= chercheTeamNames('BSP')
                console.log ('teamnames'+ JSON.stringify(teamnames))
                console.log (teamnames)
                
                

                if (user_id) { registerClientId(user_id); }               // on s 'enregistre sur le websocket avec l id '

                // Si le bateau Inconnu le selectdepart est le depart et  le selectarrivee est l arrivee de la premiere course  
                var selectini = username == 'Bateau Inconnu' ? 1 : 0;       // position vr par defaut 
                document.getElementById('idusername').value = username

                // on affiche le selectcourse   
                let tabValeurs = tabNameCourses.map(subArray => subArray[0]);
                let tabNoms = tabNameCourses.map(subArray => subArray[1]);

                let coursesUser = await cherchecoursesuser(username) // on cherche les courses en cours du username

                console.log('coursesUser issues du serveur :')
                console.log(coursesUser)

                if (coursesUser == null)   //si l utilisateur est Bateau Inconnu on lui a attribu√© une course d'office 
                { // on est dans le cas d'un nouveau bateau ou de bateau inconnu qui n a pas encore de courses repertori√©es 
                    course = tabNameCourses[0][0];
                    coursesUser = [course]
                }
                var selectcourse = generateSelect('idcourse', tabValeurs, tabNoms, coursesUser, course, 'limited-width-select-200')
                document.getElementById('idselectcourse').innerHTML = selectcourse


                //****************************************************************************
                // ********** On recherche les personalinfos 
                //****************************************************************************
                console.log(`Recherche de PersonalInfos  pour ${username}  ${user_id} sur  course ${course}`)
                personalInfosStr = await recherchepersonalinfos(username, user_id, course)
                personalInfosJS = JSON.parse(personalInfosStr);

                console.log('personalinfos  issues du serveur ' + personalInfosStr)

                affichewaypoints2(personalInfosJS)
                afficheZonesExclusions(personalInfosJS)

                afficheBarrieres(personalInfosJS)
                
                recupereRoutes(personalInfosJS)

                waypoints = Object.values(personalInfosJS.wp).sort((a, b) => a[0] - b[0]);
                nomsWaypoints = waypoints.map(item => item[1]);
                // ari=personalInfosJS['ari']                         // Pour l instant on va utiliser ari de memoiretrajets et non celui de personalinfos 

                // console.log('ligne 3971 waypoints ' + waypoints + ' ari ' + ari)
                afficheselectarrivee(waypoints, ari)// on affiche le select arrivee avec les waypoints et ceux selectionnes  contenus dans localstorage

                if (typeof ari === "undefined") {
                    ari = ['Arrivee'];
                }


                // ici on peut afficher les coordonnees du dernier wp selectionn√© qui est le dernier element de ari 
                nomdernierwp = ari[ari.length - 1]                                        // nom du dernier wp
                waypoint = waypoints.find(waypoints => waypoints[1] === nomdernierwp) // on le recherche dans la liste 
                try {
                    y1 = waypoint[2]
                    x1 = waypoint[3]
                }
                catch { y1 = 47; x1 = -3; nomdernierwp = 'test' }

                document.getElementById('iddernierwp').innerHTML = nomdernierwp
                affichecoordsari(y1, x1)

                // pour pouvoir numeroter les waypoints 
                nbWP = personalInfosJS.wp ? Object.keys(personalInfosJS.wp).length : 0;
                console.log('nbWP : ' + nbWP)



                //****************************************************************************
                //****************************************************************************

                // on affiche le select depart 
                tabNoms = ['Position VR - Heure VR ', 'Coordonn√©es / Heure Manuelle ', 'Coordonn√©es / Heure Depart ']
                tabValeurs = [0, 1, 2]
                grises = []
                selectdepart = generateSelect('iddepart', tabValeurs, tabNoms, grises, selectini, 'limited-width-select-100')
                document.getElementById('idselectdepart').innerHTML = selectdepart

                // on va chercher leginfos      qui donne les particularites de la course 
                // probl√®me si la course n a jamais ete initiee   a voir dans chgt course 

                //   console.log (leginfos)

                // On va chercher les donnees les plus recentes sur le bateau 
                boatinfosdata = await chercheboatinfos(username, course)


                boatinfosJSON = JSON.parse(boatinfosdata.result)
                //console.log('boatinfosdata\n' + boatinfosdata.result)


                try {


                    console.log(' tabexclusions ' + boatinfosJSON['leg']['restrictedZones'])
                    console.log ('Zones Exclusions ' + JSON.stringify ( boatinfosJSON['leg']['restrictedZones']))
                    nbzones = boatinfosJSON['leg']['restrictedZones'].length
                    zonesExclusions.length = (nbzones)
                    for (var i = 0; i < nbzones; i++) {
                        vertices = boatinfosJSON['leg']['restrictedZones'][i]['vertices']
                        nbPoints = vertices.length
                        pointsvertice = new Array(nbPoints + 1)
                        for (var j = 0; j < nbPoints; j++) { pointsvertice[j] = [vertices[j]['lat'], vertices[j]['lon']] }
                        pointsvertice[nbPoints] = [vertices[0]['lat'], vertices[0]['lon']]  // on referme le polygone
                        zonesExclusions[i] = pointsvertice
                    }
                    console.log("Zones d'Exclusions")
                    console.log(zonesExclusions)
                }
                catch { zonesExclusions = []; console.log('Pas de zones d exclusion pour la course dansboatinfosdata') }

                // lignes exclusions si elles existent 
                try { L.polyline(zonesExclusions).setStyle({ color: 'red', weight: 1, opacity: 1, }).addTo(lgDashLines); }
                catch { 'console.log pas de zones d exclusion' }




                console.log('boatinfosdata ' + boatinfosdata)

                //    console.log (`boatinfosdata recuperees \n********************\n`)
                //    console.log ('boatinfosdata ' +boatinfosdata)
                //    console.log ('boatinfosdata keys ' +Object.keys(boatinfosdata))
                //   console.log ('boatinfosdata.result'+boatinfosdata.result)
                boatinfosJSON = JSON.parse(boatinfosdata.result)
                //console.log('boatinfos' + boatinfos)

                user_id = boatinfosJSON['bs']['_id']['user_id']
                state = boatinfosJSON['bs']['state']
                legStartDate = boatinfosJSON['bs']['legStartDate']
                // console.log('user_id ' + user_id)
                // console.log('State ' + state)
                // console.log('legStartDate ' + legStartDate)
                // on les affiche 
                if (boatinfosdata.result == null) {/*utilisateurinconnu()*/console.log('Utilisateur inconnu '); affichecoordsdep(ycoord, xcoord) }
                // on va mettre a jour  memoiretrajets avec les donnees recuperes  




                afficheboatinfos(boatinfosdata)


                // on va chercher progsvr       qui donne la derni√®re  programmations enregistr√©es pour le user et la course 
                try { await chercheprogsvr(user_id, course, t0routage) }
                catch { console.log('Probleme dans la recuperation de progsvr') }





                //  les valeurs pour les voiles et le vent sont traitees avec l affichage boatinfos 

                /// Partie relative au websocket 
                //**********************************************************************************************************
       //        console.log(' user_id ' + user_id)


//             if (sourceinfos=='dash' && isMe == 'no')
// {
//             // On est dans le cas ou on route un concurrent 
//   console.log ('on remplit avec les coordonnees du concurrent ')    
  
  
//                 //         // trouve dernier trajet a retabli l ancienne valeur de waypoints  
//                          username = posStart.username
//                 //    // teamname = posStart.teamname
//                 //    // sourcedash = posStart.source
//                 race = posStart.race
//                 leg = posStart.leg
//                 course = race + '.' + leg
//                 y0vr = posStart['lat']               // Derni√®re position VR 
//                 x0vr = posStart['lon']
//                 t0 = posStart['lastCalcDate']      // dernier temps de calcul en s   
                        
                        
//  //         trajet = trouvederniertrajet()
//                 //         ari = trajet[11]
//                 //         waypoints = trajet[12]



// } 


            }//fin du main 








            socket.on("connect", async () => {
                console.log("WebSocket connect√© (SID)", socket.id);
                // setStatusIndicator(true)
                // On attend que le serveur nous donne l'user_id plus tard

                if (user_id) {
                    console.log("‚û°Ô∏è R√©-enregistrement auto de", user_id);
                    registerClientId(user_id)

                    console.log('on va proceder a une mise a jour  pour ' + username + ' course ' + course)

                    await main()
                    // update(username, course, 0 )      // le 0  cest pour pas bloqu√© par routage 
                    console.log('update termin√©')

                }

            });





            //***************************************************************************************************************
            //********  Changement Utilisateur                                                          ******************************
            //***************************************************************************************************************


            async function changementuser(username) {
                console.log(' Changement user  Nouveau  ' + username)
                console.log('***************************************************')

                bloque = 1    // on bloque l update    

                console.log('username2 ' + username)
                course = document.getElementById('idcourse').value
                routageLayer.clearLayers()
                boatMarkers.clearLayers()
                fleetMarkers.clearLayers()
                layerExclusions.clearLayers()
                WpCirclesLayer.clearLayers();
                routageCircles.clearLayers();
                isochronesLayer.clearLayers()
                progsvrLayer.clearLayers()
                document.getElementById("inputCoordinates").value = ''


                // on affiche le selectcourse   correctement pour le user 
                let tabValeurs = tabNameCourses.map(subArray => subArray[0]);
                let tabNoms = tabNameCourses.map(subArray => subArray[1]);

                personalInfosStr = await recherchepersonalinfos(username, user_id, course)
                console.log('personalInfosStr ' + personalInfosStr)     // si il n'y en a pas la fonction en cree un avec la course
                personalInfosJS = JSON.parse(personalInfosStr);


                let coursesUser = await cherchecoursesuser(username) // on cherche les courses en cours du username
                if (coursesUser == null)   //si l utilisateur est Bateau Inconnu on lui a attribu√© une course d'office 
                { // on est dans le cas d'un nouveau bateau ou de bateau inconnu qui n a pas encore de courses repertori√©es 
                    course = tabNameCourses[0][0];
                    coursesUser = [course]
                }
                course = coursesUser[0]
                var selectcourse = generateSelect('idcourse', tabValeurs, tabNoms, coursesUser, course, 'limited-width-select-200')
                document.getElementById('idselectcourse').innerHTML = selectcourse



                // on va voir dans le local storage et dans boatinfos 
                trajet = trouvetrajetcomplet(username, course)
                console.log('trajet trouve en ligne 2362 \n*********************************')



                console.log(trajet)
                if (!Array.isArray(trajet) || trajet.length === 0) {
                    console.log(`Le tableau trajet est vide ou undefined pour  ${username} sur la course ${course} .`);
                    // on va creer le trajet 
                    //  trajet=
                    //  updateTrajet(username, course, trajet)              // sauve le trajet et le place en premier  



                }







                boatinfosdata = await chercheboatinfos(username, course)
                boatinfos = boatinfosdata.result
                boatinfosjson = JSON.parse(boatinfos)


                if (boatinfos != null) {

                    console.log('On a des donnees dans boatinfos')
                    user_id = boatinfosjson['bs']['_id']['user_id']
                    y0vr = boatinfosjson['bs']['pos']['lat']
                    x0vr = boatinfosjson['bs']['pos']['lon']
                    twsvr = boatinfosjson['bs']['tws']
                    twavr = boatinfosjson['bs']['twa']
                    t0vr = boatinfosjson['bs']['lastCalcDate'] / 1000
                    polar_id = boatinfosjson['bs']['boat']['polar_id']
                    stamina = boatinfosjson['bs']['stamina']
                    sail = boatinfosjson['bs']['sail']

                    afficheboatinfos(boatinfosdata)       // visiblement ne se met a jour qu a l update  ? 
                    document.getElementById('iddepart').selectedIndex = 0 // on peut afficher un selectdepart avec Position VR 
                    y0 = y0vr
                    x0 = x0vr

                    if (trajet.length != 0) {
                        document.getElementById('iddepart').selectedIndex = 0 // on peut afficher un selectdepart avec Position VR 
                        console.log(' il y a des boatinfos et un trajet donc des WP')
                        ari = trajet[11]
                        waypoints = trajet[12]
                        nomdernierwp = ari[ari.length - 1]
                        dernierwaypoint = waypoints.find(waypoints => waypoints[1] === nomdernierwp) // on le recherche dans la liste 
                        y1 = dernierwaypoint[2]
                        x1 = dernierwaypoint[3]
                        // pour l affichage des coordonnees du depart
                        trajet[2] = y0vr
                        trajet[3] = x0vr
                        trajet[4] = t0vr
                        // Le trajet etant deja existant on nemodifie que les coordonnnees de depart        

                    }

                    else {
                        //console.log(' il y a des boatinfos mais pas de trajet // on cree un trajet et le select d arrivee ')
                        document.getElementById('iddepart').selectedIndex = 0
                        let courseencours = tabNameCourses.find(tabNameCourses => tabNameCourses[0] === course)
                        y1 = courseencours[5][0]
                        x1 = courseencours[5][1]
                        var rayonari = courseencours[5][4]
                        waypoints = [[99, "Arrivee", y1, x1, rayonari]]
                        trajet = [username, course, y0vr, x0vr, y0vr, x0vr, t0vr, y1, x1, -1, user_id, ['Arrivee'], waypoints, 'Nouvel Utilisateur']
                    }

                    //valable dans les 2 cas
                    updateTrajet(username, course, trajet)              // sauve le trajet et le place en premier  
                    affichewaypoints2(personalInfosJS)
                    //affichewaypoints(waypoints)
                    affichecoordsdep(y0, x0)
                    affichecoordsari(y1, x1)
                    afficheselectarrivee(waypoints, ari)   // on remet a jour le selectari 
                    map.panTo([y0, x0])

                }  // fin du cas ou il y a des boatinfos 


                // il n'y a pas de boatinfos mais peut etre un trajet 
                else {

                    if (trajet.length != 0) {
                        console.log(' il y a des boatinfos et un trajet donc des WP')
                        ari = trajet[11]
                        waypoints = trajet[12]
                        nomdernierwp = ari[ari.length - 1]
                        dernierwaypoint = waypoints.find(waypoints => waypoints[1] === nomdernierwp) // on le recherche dans la liste 
                        y1 = dernierwaypoint[2]
                        x1 = dernierwaypoint[3]

                        // pour l affichage des coordonnees du depart
                        y0 = trajet[1]
                        x0 = trajet[2]
                        updateTrajet(username, course, trajet)              //  replace le trajet en premier  
                        affichewaypoints(waypoints)
                        affichecoordsdep(y0, x0)
                        affichecoordsari(y1, x1)
                        afficheselectarrivee(waypoints, ari)   // on remet a jour le selectari 
                        map.panTo([y0, x0])
                    }

                    else {
                        console.log(' l utilisateur ' + username + ' n est connu ni dans boatinfos ni dans les trajets ')
                        utilisateurinconnu2(username, course)
                    }

                }
                bloque = 0
            }








            //***************************************************************************************************************
            //********  Changement course                                                      ******************************
            //***************************************************************************************************************

            // on a besoin de mettre a jour
            // La position du bateau ou le point de depart si pas de trajet existant  
            // le selecteur d arrivee 
            // les waypoints si existants 
            // Les parametres de voile
            // Le lien pour les polaires en fonction du vent 
            // les lignes et tableau  de programmation si existants 
            // la maj meteo sera traitee independamment 


            async function changementcourse(username, course) {
                console.log(' Nouvellecourse :' + course + ' pour ' + username)
                console.log('***************************************************')
                // On efface tout 
                lgMarkers.clearLayers();
                lgDashLines.clearLayers();
                routageLayer.clearLayers();
                boatMarkers.clearLayers();
                layerExclusions.clearLayers();
                WpCirclesLayer.clearLayers();
                routageCircles.clearLayers();
                isochronesLayer.clearLayers()
                progsvrLayer.clearLayers();
                progsvrLayerJaune.clearLayers();
                circleBoatLayer.clearLayers();
                cartesLayer.clearLayers();
                fermerEditeurRoutes()
                document.getElementById("inputCoordinates").value = ''
                zonesPolygones = {};      // on vide la liste des polygones perso 
                listeZones = []                   // on vide la liste des zones exclusion perso 
                waypointsjs = {}
                for (let nom in polylines) {
                    if (map.hasLayer(polylines[nom])) {
                        map.removeLayer(polylines[nom]);
                    }
                }

                routes = [];             // Liste des routes
                nomsroutages = [];       // Noms des routages
                polylines = {};          // Objets Leaflet des routes affich√©es
                document.getElementById('tableroutages').innerHTML = ""; // Efface le tableau des routes

                let courseencours = tabNameCourses.find(tabNameCourses => tabNameCourses[0] === course)
                console.log('courseencours')

                var selectini = username == 'Bateau Inconnu' ? 1 : 0;       // position vr par defaut 
                // on n a pas besoin de changer le selectcourse qui reste identique 
                // on recupere les personalinfos  s il n y en a pas sur cette course une ligne est ouverte automatiquement


                // on affiche le selectcourse   avec la valeur de la course 
                let tabValeurs = tabNameCourses.map(subArray => subArray[0]);
                let tabNoms = tabNameCourses.map(subArray => subArray[1]);
                let coursesUser = await cherchecoursesuser(username) // on cherche les courses en cours du username

                console.log('coursesUser issues du serveur :')
                console.log(coursesUser)

                if (coursesUser == null)   //si l utilisateur est Bateau Inconnu on lui a attribu√© une course d'office 
                { // on est dans le cas d'un nouveau bateau ou de bateau inconnu qui n a pas encore de courses repertori√©es 
                    course = tabNameCourses[0][0];
                    coursesUser = [course]
                }
                var selectcourse = generateSelect('idcourse', tabValeurs, tabNoms, coursesUser, course, 'limited-width-select-200')
                document.getElementById('idselectcourse').innerHTML = selectcourse


                personalInfosStr = await recherchepersonalinfos(username, user_id, course)
                console.log('personalInfosStr ' + personalInfosStr)     // si il n'y en a pas la fonction en cree un avec la course
                personalInfosJS = JSON.parse(personalInfosStr);
                console.log(`personalInfos  pour ${username} sur la course ${course}\n*************************************************\n${personalInfosStr}`)

                affichewaypoints2(personalInfosJS)
                waypoints = Object.values(personalInfosJS.wp).sort((a, b) => a[0] - b[0]);
                nomsWaypoints = waypoints.map(item => item[1]);
                ari = personalInfosJS['ari']
                afficheselectarrivee(waypoints, ari)// on affiche le select arrivee avec les waypoints et ceux selectionnes  
                // ici on peut afficher les coordonnneses du dernier wp selectionn√© qui est le dernier element de ari 
                nomdernierwp = ari[ari.length - 1]                                        // nom du dernier wp
                waypoint = waypoints.find(waypoints => waypoints[1] === nomdernierwp) // on le recherche dans la liste 
                let y1 = waypoint[2]
                let x1 = waypoint[3]
                document.getElementById('iddernierwp').innerHTML = nomdernierwp
                affichecoordsari(y1, x1)

                // pour pouvoir numeroter les waypoints 
                nbWP = personalInfosJS.wp ? Object.keys(personalInfosJS.wp).length : 0;
                console.log('nbWP : ' + nbWP)



                //****************************************************************************
                //****************************************************************************

                // on affiche le select depart 
                tabNoms = ['Position VR - Heure VR ', 'Coordonn√©es / Heure Manuelle ', 'Coordonn√©es / Heure Depart ']
                tabValeurs = [0, 1, 2]
                grises = []
                selectdepart = generateSelect('iddepart', tabValeurs, tabNoms, grises, selectini, 'limited-width-select-100')
                document.getElementById('idselectdepart').innerHTML = selectdepart

                // on va chercher leginfos      qui donne les particularites de la course 
                // probl√®me si la course n a jamais ete initiee   a voir dans chgt course 
                leginfos = await chercheleginfos(course)
                console.log('leginfos\n***********\n' + leginfos)

                afficheZonesExclusions(personalInfosJS)
                afficheBarrieres(personalInfosJS)
                // On va chercher les donnees les plus recentes sur le bateau 
                boatinfosdata = await chercheboatinfos(username, course)
                //    console.log ('boatinfosdata ' +boatinfosdata)
                //    console.log ('boatinfosdata keys ' +Object.keys(boatinfosdata))
                //    console.log ('boatinfosdata.result'+boatinfosdata.result)



                // on les affiche 
                if (boatinfosdata.result == null) {
    /*utilisateurinconnu()*/console.log('Utilisateur inconnu '); affichecoordsdep(ycoord, xcoord)
                }


                // on va sauver un trajet pour y revenir directement la prochaine fois 

                let t0 = document.getElementById('datetime').value
                let dateObj = new Date(t0);
                let t0Secondes = Math.floor(dateObj.getTime() / 1000);
                let t0formate = formatTime(t0Secondes)
                let y0 = courseencours[4][0]
                let x0 = courseencours[4][1]
                y1 = courseencours[5][0]
                x1 = courseencours[5][1]
                // waypoints et ari ont deja ete recuperes
                // waypoints=[[99, "Arrivee", y1, x1, rayonari]]
                // ari=['Arrivee']
                trajet = [username, course, y0, x0, y0, x0, t0, y1, x1, -1, user_id, ari, waypoints, 'New' + username + ' ' + t0formate]
                updateTrajet(username, course, trajet)   // sauve le trajet  
                map.panTo([y0vr, x0vr])               // on centre la carte 
                // on charge la cartevr


                afficheleginfos(leginfos)
                afficheboatinfos(boatinfosdata)
                // on va remettre l eta et la duree a 0 
                document.getElementById('eta').innerHTML = 'Pas de Routage '
                // on se positionne sur le bateau
                map.panTo([y0vr, x0vr])
                // on charge la cartevr
                carte = await chargecartemaps2(y0vr, x0vr)
                affichecarte(carte)

            }




            //***************************************************************************************************************
            //********  Nouvel Utilisateur inconnu dans la base de donnees donc dans les trajets    *************************
            //***************************************************************************************************************

            function utilisateurinconnu2(username, course) {

                console.log('Nouvel Utilisateur ' + username + ' sur la course ' + course + ' inconnu dans la base de donnees et dans les trajets ');

                // on lui cree un trajet depart arrivee avec la course en cours par defaut 
                //courseencours        = document.getElementById('idcourse').value
                coursecomplete = tabNameCourses.find(tabNameCourses => tabNameCourses[0] === course)
                let t0 = document.getElementById('datetime').value
                let dateObj = new Date(t0);
                let t0Secondes = Math.floor(dateObj.getTime() / 1000);
                let t0formate = formatTime(t0Secondes)
                y0 = coursecomplete[4][0]
                x0 = coursecomplete[4][1]
                y1 = coursecomplete[5][0]
                x1 = coursecomplete[5][1]

                try { var rayonari = courseencours[0][5][4] } catch { rayonari = 0 }   // cas ou l arrivee est une ligne 
                waypoints = [[99, "Arrivee", y1, x1, rayonari]]
                ari = ['Arrivee']
                console.log('on enregistre le trajet comme un nouveau trajet car il n existe pas deja ');
                trajet = [username, course, y0, x0, y0, x0, t0, y1, x1, -1, user_id, ari, waypoints, 'New' + username + ' ' + t0formate]
                document.getElementById('iddepart').selectedIndex = 1 // selectdepart avec coordonnnees 
                updateTrajet(username, course, trajet)    // sauve le trajet pour la prochaine fois 
                document.getElementById('iddepart').selectedIndex = 0     // inconnu selectdepart sur coordonnnees 
                affichecoordsdep(y0, x0)
                afficheselectarrivee(waypoints, ari)
                affichecoordsari(y1, x1)
                // valeurs arbitraires pour l affichage du bateau 
                twsvr = 10
                twdvr = 270
                heading = 0
                //  afficheBoat(y0, x0, t0Secondes, twsvr, twdvr, heading, username)
                afficheBoat2(y0, x0, t0Secondes, twsvr, twdvr, heading, twavr, 0, 0, username, 'blue')

                map.panTo([y0, x0])


            }





            //*******************************************************************************************************
            //**********  Fonctions d affichage diverses   **********************************************************
            //*******************************************************************************************************




            // function afficheprogsvr(data) {
            //     //  programmationsJson=JSON.parse(data.programmations)  
            //     // console.log (' Ligne 3686 type de programmations '+data.programmations)   
            //     console.log('Type de programmations : ' + data.typeprogs)



            //     if (data.typeprogs == "progs") {
            //         console.log('On a affaire a des progs')
            //         afficheligneprogs(data)   //# on peut alors tracer la polyline  tracer
            //         //   affichetabprogsvr(data) 
            //     }

            //     else if (data.typeprogs == "wps") {
            //         console.log('On a affaire a des wp')

            //         afficheligneprogs(data)   //# on peut alors tracer la polyline  tracer
            //         //   affichetabwpvr(data)
            //         // affichelignewaypoints2(polylineprogs)
            //     }

            //     else (console.log('Probleme dans la recuperation progs ou wp  '))

            // }









            function affichelignewaypoints(data) {

                lgMarkersVR.clearLayers()
                progsvrLayer.clearLayers()

                //console.log ('on est dans affichelignewaypoints  ')
                // console.log('data'+data.programmations)

                waypointsvr = JSON.parse(data.programmations)
                polylineprogs = data.polyline

                for (var i = 0; i < waypointsvr.length; i++) {   //Cercles de couleur blanche pour les WP
                    latwp = waypointsvr[i]['WPLat']
                    lonwp = waypointsvr[i]['WPLon']
                    circlewp = L.circle([latwp, lonwp], { fillColor: 'white', color: 'white', weight: 1, opacity: 1, fillOpacity: 0, radius: 500, }).bindTooltip('WP' + (i + 1)).addTo(lgMarkersVR)
                }

                for (var i = 0; i < polylineprogs.length; i++) {
                    tooltip[i] = intlhmn.format(polylineprogs[i][4] * 1000) + '<br>' + typeVoiles[polylineprogs[i][5]]
                    circleprog2[i] = L.circle([polylineprogs[i][0], polylineprogs[i][1]], { fillColor: 'white', color: colors[polylineprogs[i][5]], weight: 1, opacity: 1, fillOpacity: 0, radius: 100, }).bindTooltip(tooltip[i]).addTo(lgMarkersVR)
                }

                lgMarkersVR.addTo(map)
            }






            function afficheZonesExclusions(personalInfosJS) {
                console.log("Affichage des zones d'exclusion");

                // Vider le layer avant de tout recharger
                layerExclusions.clearLayers();
                listeZones = [];
                zonesPolygones = {};

                console.log ('personalinfosexclusions '+JSON.stringify(personalInfosJS.exclusions))

                if (personalInfosJS.exclusions) {
                    Object.entries(personalInfosJS.exclusions).forEach(([nomZone, zone]) => {
                        console.log("Valeurs de la zone d'exclusion :", zone);

                        let polygone = L.polygon(zone)
                            .setStyle({ color: 'black', fillColor: 'blue', weight: 0.5, fillOpacity: 0.2 })
                            .bindTooltip(nomZone, { permanent: false, direction: "center", className: "zone-tooltip" })
                            .on("click", () => ouvrirEditeurExclusions(nomZone, zone)) // üîπ Ouvrir l'√©diteur sur clic
                            .addTo(layerExclusions);

                        listeZones.push(nomZone);
                        zonesPolygones[nomZone] = polygone; // üîπ Stocker la zone pour suppression rapide
                    });

                    layerExclusions.addTo(map)
                }
            }





            function afficheleginfos(leginfos)  // affiche les particularites de la course
            {  //leginfos contient les marques les zones exclusion la trajectoire 

                if (leginfos != null) {
                    leginfos = JSON.parse(leginfos)
                    lgMarkers.clearLayers();  // Contient les lignes de checkpoints   
                    lgDashLines.clearLayers();

                    //console.log  ('checkpoints '+leginfos['checkpoints'])

                    // on recupere les lignes de checkpoint 
                    var nombreLignes = leginfos['checkpoints'].length

                    tabLignesCheckPoints.length = nombreLignes
                    for (var i = 0; i < nombreLignes; i++) {
                        var starti = [leginfos['checkpoints'][i]['start']['lat'], leginfos['checkpoints'][i]['start']['lon'], leginfos['checkpoints'][i]['name']]
                        var endi = [leginfos['checkpoints'][i]['end']['lat'], leginfos['checkpoints'][i]['end']['lon'], leginfos['checkpoints'][i]['name']]
                        var displayi = leginfos['checkpoints'][i]['display']
                        tabLignesCheckPoints[i] = [starti, endi, displayi]
                    }
                    console.log('Lignes de checkpoints r√©cup√©r√©es')
                    //console.log (tabLignesCheckPoints)

                    // tracage des lignes de checkpoints
                    for (var i = 0; i < tabLignesCheckPoints.length; i++) {
                        let y0 = tabLignesCheckPoints[i][0][0]
                        let x0 = tabLignesCheckPoints[i][0][1]
                        let y1 = tabLignesCheckPoints[i][1][0]
                        let x1 = tabLignesCheckPoints[i][1][1]
                        tracearc(y0, x0, y1, x1)
                        // on va mettre un marqueur a chaque point de depart  

                        //L.marker([y0,x0 ],    {icon: blackIcon}).bindTooltip(tabLignesCheckPoints[i][0][2]).addTo(lgMarkers)     
                        // L.circle([y0,x0] ,{fillColor: 'white' ,color:'green' , weight:1 ,opacity:1,fillOpacity: 0,radius: 100,}).bindTooltip('bouee').addTo(lgMarkersVR)

                    }
                    // On recupere les points du trace de la course servant a definir la courbe de bezier   
                    var tracecourse = leginfos['course']



                    // console.log ('Itineraire  de la course ', tracecourse)


                    nbpt = tracecourse.length
                    polylineCurve.length = nbpt
                    for (var i = 0; i < nbpt; i++) { polylineCurve[i] = [tracecourse[i]['lat'], tracecourse[i]['lon']] }



                    // on recupere les zones d exclusions  si elles existent 
                    try {
                        nbzones = leginfos['restrictedZones'].length
                        zonesExclusions.length = (nbzones)
                        for (var i = 0; i < nbzones; i++) {
                            vertices = leginfos['restrictedZones'][i]['vertices']
                            nbPoints = vertices.length
                            pointsvertice = new Array(nbPoints + 1)
                            for (var j = 0; j < nbPoints; j++) { pointsvertice[j] = [vertices[j]['lat'], vertices[j]['lon']] }
                            pointsvertice[nbPoints] = [vertices[0]['lat'], vertices[0]['lon']]  // on referme le polygone
                            zonesExclusions[i] = pointsvertice
                        }
                        console.log("Zones d'Exclusions R√©cup√©r√©es ")
                        console.log(zonesExclusions)
                    }
                    catch { zonesExclusions = []; console.log('Pas de zones d exclusion pour la course') }

                    // on recupere la zone de glace si elle existe 
                    tabicelimits = leginfos['ice_limits']['south']

                    const polyicelimit = tabicelimits.map(({ lat, lon }) => [lat, lon]);
                    //console.log ('Limite des glaces')
                    //console.log(polyicelimit);
                    Lpolyicelimit = L.polyline(polyicelimit).setStyle({ color: 'red', weight: 2, opacity: 1, }).addTo(lgMarkers)



                    //remplissage du select de depart et arrivee 
                    indiceCourse = rechercheindice2(tabNameCourses, course)
                    //console.log('indiceCourse '+indiceCourse)      
                    depart = [tabNameCourses[indiceCourse][4][0], tabNameCourses[indiceCourse][4][1], tabNameCourses[indiceCourse][4][2]]
                    arrivee = [tabNameCourses[indiceCourse][5][0], tabNameCourses[indiceCourse][5][1], tabNameCourses[indiceCourse][5][2]]
                    // [y,x,nom]
                    // affichagecoordsDep(tabNameCourses[indiceCourse][4][0],tabNameCourses[indiceCourse][4][1])
                    // ca ce sont les coordonnees du depart de la course 

                    //Marqueurs depart arrivee et cercle arrivee
                    L.marker(depart, { icon: greenIcon }).bindTooltip(tabNameCourses[indice][4][2]).addTo(lgMarkers)
                    L.marker(arrivee, { icon: redIcon }).bindTooltip(tabNameCourses[indice][5][2]).addTo(lgMarkers)
                    radiusend = tabNameCourses[indice][5][4] * 1852
                    var circleari = new L.circle(arrivee, { color: 'white', weight: 0.7, fillColor: '#f03', opacity: 1, fillOpacity: 0, radius: radiusend, }).addTo(lgMarkers);

                    // lignes de checkpoints
                    for (var i = 0; i < tabLignesCheckPoints.length; i++) {
                        y0 = tabLignesCheckPoints[i][0][0]
                        x0 = tabLignesCheckPoints[i][0][1]
                        y1 = tabLignesCheckPoints[i][1][0]
                        x1 = tabLignesCheckPoints[i][1][1]
                        tracearc(y0, x0, y1, x1)
                        // on va mettre un marqueur a chaque point de depart  
                        L.marker([y0, x0], { icon: blackIcon }).bindTooltip(tabLignesCheckPoints[i][0][2]).addTo(lgMarkers)
                        L.circle([y0, x0], { fillColor: 'white', color: 'black', weight: 1, opacity: 1, fillOpacity: 0, radius: 500, }).bindTooltip('bouee').addTo(lgMarkers)
                    }
                    troncons = couperPolyligneLongitude(polylineCurve)       // trajectoire theorique 
                    troncons.forEach(troncon => {
                        var bezierPath = createBezierPath(troncon);
                        try { L.curve(bezierPath, { color: 'blue', weight: 2 }).addTo(lgDashLines); }
                        catch { console.log('Le trace a echou√©') }
                    });

                    // lignes exclusions si elles existent 
                    try { L.polyline(zonesExclusions).setStyle({ color: 'red', weight: 1, opacity: 1, }).addTo(lgDashLines); }
                    catch { 'console.log pas de zones d exclusion' }


                    lgMarkers.addTo(map)
                    lgDashLines.addTo(map)

                }

                else { alert('Vous devez d abord vous connecter sur la course avec le dashboard connect√© pour avoir les informations sur la course ') }
                //WpCirclesLayer.addTo(map) la place est plutot dans l affichage des donnees perso

            }   // fin de affiche leginfos



            function affichecarte(carte)  // affiche les particularites de la course
            {
                Lcarte = L.polyline(carte).setStyle({ color: 'purple', weight: 1, opacity: 1, }).addTo(cartesLayer)
                cartesLayer.addTo(map)
            }






            function affichagerecou(tabrecouvrements) {
                // console.log (' fonction affichagerecou')
                // console.log (tabrecouvrements)
                tableau = tabrecouvrements
                texte = '<div class="recou">Recouvrements </div>';
                texte += "<tr><td>----</td><td>----</td><td>" + typeVoiles[tableau[0][0]] + "</td><td>" + tableau[0][2].toFixed(1) + "</td><td>" + tableau[0][4].toFixed(1) + "</td></tr>"
                for (var i = 1; i < tableau.length - 1; i++) {
                    texte += "<tr><td>" + tableau[i][3].toFixed(1) + "</td><td>" + tableau[i][1].toFixed(1) + "</td><td>" + typeVoiles[tableau[i][0]] + "</td><td>" + tableau[i][2].toFixed(1) + "</td><td>" + tableau[i][4].toFixed(1) + "</td></tr>"
                }
                texte += "<tr><td>" + tableau[i][3].toFixed(1) + "</td><td>" + tableau[i][1].toFixed(1) + "</td><td>" + typeVoiles[tableau[i][0]] + "</td><td>----</td><td>----</td></tr>"
                document.getElementById('tabrecou').innerHTML = texte
            }





            function progressbar(y0, x0, y1, x1) //function progressbar(y0,x0,y1,x1,carabateau)
            {
                //moyenne=carabateau['maxSpeed']/2      # necessite de charger polairesjson 
                moyenne = 15
                res = dist_cap_ortho(y0, x0, y1, x1)
                temps_trajet = res[0] / moyenne
                t_calcul = ((temps_trajet - 12) + 72) * 0.04 / 1.1 //72 isochrones pour les 12 premieres heures + 1 par h  le /1.5 est pour le nouvel algorithme
                nbprogress = 0;
                duree = t_calcul;
                var max = 100;
                intervalid = setInterval(function () {
                    nbprogress++; if (nbprogress > max) { clearInterval(intervalid); };
                    document.getElementById('progress').value = nbprogress;
                }, 10 * duree);
            }






            //*********************************************************************************************************************
            //**************      Ecouteurs (Listeners)    ***********************************************************************
            //*********************************************************************************************************************

            // idusername          changement user   
            // inputCoordinates    Coordonnees coll√©es dans champ 
            // datetime            Changement datetimedepart
            // idselectarrivee     changement arrivee 
            // idselectdepart      Changement depart
            // idcourse            Changement de course 
            // cocheexclusions     Activation des exclusions 
            // showisochrones      Affichage des isochrones
            // showprogsvr         Affichage des programmations vr (UI) sur la carte  
            // twsvmg              Affichage des vmg et des recouvrements 
            // dupliquerprogsvr    Dupplique les progs Vr dans les programmations jaunes 
            // lancerroutage       Lance le routage  
            // detailroute2        Affiche le detail du routage
            // rafraichir          Pour rafraichir l affichage des progs vr 


            // 


            // ecouteur changement user 
            var idusername = document.getElementById('idusername')
            idusername.addEventListener("change", function (evt) {
                let username2 = document.getElementById('idusername').value
                changementuser(username2)

            });





            // √âcouteur pour l'√©v√©nement "paste" sur input Coordinates
            document.getElementById("inputCoordinates").addEventListener("paste", (event) => {

                event.preventDefault();     // Emp√™cher le comportement par d√©faut si n√©cessaire
                const clipboardData = event.clipboardData || window.clipboardData;   // R√©cup√©rer le texte coll√©
                const pastedData = clipboardData.getData("text");
                event.target.value = pastedData;                                     // Ins√©rer le texte coll√© dans le champ    
                const { latDecimal, lngDecimal } = dmsToDecimal(pastedData);         // Conversion des coordonn√©es en d√©cimales
                console.log('latDecimal ' + latDecimal)
                console.log('lngDecimal ' + lngDecimal)
                y0 = latDecimal
                x0 = lngDecimal
                affichecoordsdep(y0, x0)

                let t0 = document.getElementById('datetime').value
                let dateObj = new Date(t0);
                var t0Secondes = Math.floor(dateObj.getTime() / 1000);
                var t0formate = formatTime(t0Secondes)

                let username = document.getElementById('idusername').value
                let course = document.getElementById('idcourse').value
                // on va chercher s il existe deja un trajet pour ce user et cette course  
                trajet = trouvetrajet(username, course)
                // si un trajet existe on va se contenter de changer les coordonnees y1,x1

                if (trajet.length != 0) {
                    trajet[2] = y0
                    trajet[3] = x0
                    updateTrajet(username, course, trajet)
                }



                else { // le trajet est vide , on  cree un trajet }    
                    let coursecomplete = tabNameCourses.find(tabNameCourses => tabNameCourses[0] === course)

                    y0 = coursecomplete[4][0]
                    x0 = coursecomplete[4][1]
                    y1 = coursecomplete[5][0]
                    x1 = coursecomplete[5][1]

                    console.log(t0Secondes)

                    try { var rayonari = courseencours[0][5][4] } catch { rayonari = 0 }   // cas ou l arrivee est une ligne 
                    ari = ['Arrivee']
                    waypoints = [[99, "Arrivee", y1, x1, rayonari]]
                    trajet = [username, course, y0, x0, y0, x0, t0, y1, x1, -1, 1, ari, waypoints, ' ' + username + ' ' + t0formate]


                    updateTrajet(username, course, trajet)    // sauve le trajet pour la prochaine fois
                }

                tws = 10
                twd = 270
                heading = 0
                //  afficheBoat(y0, x0, t0Secondes, tws, twd, heading, username)
                afficheBoat2(y0vr, x0vr, t0, twsvr, twdvr, heading, twavr, speed, sail, username, 'blue')

                document.getElementById('iddepart').selectedIndex = 1 // on peut afficher un selectdepart avec Coordonnees  
                map.panTo([y0, x0])
            });




            // Ecouteur pour datetime de depart
            const datetimeInput = document.getElementById('datetime');
            datetimeInput.value = getCurrentLocalDateTime();  // mise a l heure du champ depart routage
            datetimeInput.addEventListener('change', () => {
                unixTimestamp = datetimeLocalToUnix(datetimeInput.value);
                console.log(`Nouvelle date s√©lectionn√©e : ${datetimeInput.value}`);
                console.log('unixTimestamp ' + unixTimestamp)
            });





            // changement sur le selectarrivee 
            var selectari = document.getElementById('idselectarrivee')
            selectari.addEventListener("change", function (evt) { // recupere les valeurs des wp selectionnes lors d 'un changement du select et les stocke dans localstorage
                console.log('Ligne 2965 changement sur arrivee')
                // ici ca doit etre le nom du select     
                let selectedValues = Array.from(idarrivee.selectedOptions).map(option => option.value);
                ari = selectedValues

                console.log("Valeurs s√©lectionn√©es pour les WP :", selectedValues);
                // on change les valeurs d ari dans le localstorage   
                memoiretrajets = JSON.parse(localStorage.getItem("memoiretrajets"))



                memoiretrajets[0][11] = ari
                localStorage.setItem('memoiretrajets', JSON.stringify(memoiretrajets))
                // on Reaffiche avec ari  
                afficheselectarrivee(waypoints, ari)


                if (ari.length > 0) {
                    let dernier = ari[ari.length - 1]
                    // // on change les coordonnees de l arrivee 
                    // dernierwp=ari[ari.length-1]
                    let dernierwaypoint = waypoints.find(ligne => ligne[1] === dernier);
                    y1 = dernierwaypoint[2]
                    x1 = dernierwaypoint[3]
                    // y1=waypoints[dernierwp-1][2]
                    // x1=waypoints[dernierwp-1][3]
                    // // console.log('dernierwp'+dernierwp)
                    // // console.log ('coordonnees dernier wp'+ waypoints[dernierwp-1][2],waypoints[dernierwp-1][3]) 
                    // // On affiche dans les co0rdas ari
                    affichecoordsari(y1, x1)
                }
            });



            // changement sur le selectdepart
            var selectDepart = document.getElementById('idselectdepart')
            selectDepart.addEventListener("change", function (evt) {
                iddepart = document.getElementById('iddepart')
                // on recupere la valeur du select 
                var valeurSelectionnee = iddepart.value;
                console.log("Valeur s√©lectionn√©e :", valeurSelectionnee);
                if (valeurSelectionnee == 0) {  // c est la position vr 

                    // On stocke provisoirement les coordonnees dans localstorage
                    var latDeg = document.getElementById("deplatDeg").value;
                    var latMin = document.getElementById("deplatMin").value;
                    var latSec = document.getElementById("deplatSec").value;
                    var latDir = document.getElementById("deplatDir").value;
                    var lngDeg = document.getElementById("deplngDeg").value;
                    var lngMin = document.getElementById("deplngMin").value;
                    var lngSec = document.getElementById("deplngSec").value;
                    var lngDir = document.getElementById("deplngDir").value;
                    var { lat, lng } = toDecimal(latDeg, latMin, latSec, latDir, lngDeg, lngMin, lngSec, lngDir);

                    console.log('latitude a stocker ' + lat + ' Longitude ' + lng)
                    // on ouvre localstorage  


                    memoiretrajets = JSON.parse(localStorage.getItem("memoiretrajets"))
                    memoiretrajets[0][2] = lat
                    memoiretrajets[0][3] = lng
                    localStorage.setItem('memoiretrajets', JSON.stringify(memoiretrajets))


                    // on reaffiche les coordonnees vr 
                    console.log(' coordonnees vr ' + y0vr + ' ' + x0vr)
                    // on vide le champ dinput copi√© coll√©
                    document.getElementById("inputCoordinates").value = " "
                    // on repositionne le bateau 
                    afficheboatinfos(boatinfosdata)

                    affichecoordsdep(y0vr, x0vr)

                }
                else {
                    // on recupere les coordonneees de localstorage et on les affiche 

                    memoiretrajets = JSON.parse(localStorage.getItem("memoiretrajets"))
                    lat = memoiretrajets[0][2]
                    lon = memoiretrajets[0][3]
                    affichecoordsdep(lat, lon)
                }


            });



            // Ecouteur Changement de course

            document.getElementById('idselectcourse').addEventListener("change", function (evt) {
                if (evt.target && evt.target.id === 'idcourse') {
                    console.log('changement de course d√©tect√©');
                    course = evt.target.value;
                    username = document.getElementById('idusername').value;
                    changementcourse(username, course);
                }
            });







            // Changement sur le showisochrones
            const checkboxiso = document.getElementById('showisochrones')
            checkboxiso.addEventListener('change', toggleIsochronesLayer)

            function toggleIsochronesLayer() {
                if (checkboxiso.checked) {
                    // Ajouter le layer √† la carte
                    isochronesLayer.addTo(map);
                } else {

                    //isochronesLayer.clearLayers()
                    // Retirer le layer de la carte
                    map.removeLayer(isochronesLayer);
                }
            }

            // Changement sur le showboat
            const checkboxboat = document.getElementById('showboat')
            checkboxboat.addEventListener('change', toggleBoatMarkers)
            function toggleBoatMarkers() {
                if (showboat.checked) {
                    console.log('visibility checked ' + document.getElementById('showboat').value)
                    boatVisibility = 1
                    console.log('boatVisibility' + boatVisibility)
                    // Ajouter le layer √† la carte
                    console.log(y0vr, x0vr, t0, twsvr, twdvr, heading, username)
                    // afficheBoat(y0vr, x0vr, t0, twsvr, twdvr, heading, username)
                    afficheBoat2(y0vr, x0vr, t0, twsvr, twdvr, heading, twavr, speed, sail, username, 'blue')


                    boatMarkers.addTo(map);
                } else {
                    boatVisibility = 0
                    console.log('boatVisibility' + boatVisibility)
                    console.log('visibility non checked ' + document.getElementById('showboat').value)
                    boatMarkers.clearLayers()
                    // Retirer le layer de la carte
                    //map.removeLayer(isochronesLayer);
                }
            }


            // Changement affichage marques
            const checkboxmarques = document.getElementById('showmarques')
            checkboxmarques.addEventListener('change', toggleMarques)

            function toggleMarques() {
                if (showmarques.checked) {
                    console.log('visibility checked ' + document.getElementById('showmarques').value)
                    marquesVisibility = 1
                    console.log('marquesVisibility' + marquesVisibility)       // Ajouter le layer √† la carte
                    lgMarkers.addTo(map);
                }
                else {
                    marquesVisibility = 0
                    console.log('marquesVisibility' + marquesVisibility)
                    console.log('Marquesvisibility non checked ' + document.getElementById('showmarques').value)
                    map.removeLayer(lgMarkers)
                    // Retirer le layer de la carte
                    //map.removeLayer(isochronesLayer);
                }
            }



            // Changement affichage flotte
            var flotteVisibility;

            const checkboxFlotte = document.getElementById('showflotte')
            checkboxFlotte.addEventListener('change', toggleFlotte)

            function toggleFlotte() {
                if (checkboxFlotte.checked) {
                    afficheFlotte()
                    console.log('visibility checked ' + document.getElementById('showflotte').value)
                    flotteVisibility = 1
                    console.log('marquesVisibility' + flotteVisibility)       // Ajouter le layer √† la carte
                    fleetMarkers.addTo(map);
                }
                else {
                    flotteVisibility = 0
                    console.log('marquesVisibility' + flotteVisibility)
                    console.log('Marquesvisibility non checked ' + document.getElementById('showflotte').value)
                    map.removeLayer(fleetMarkers)
                    // Retirer le layer de la carte
                    //map.removeLayer(isochronesLayer);
                }
            }






            // Changement sur le showprogsvr
            const showprogsvr = document.getElementById('showprogsvr')
            showprogsvr.addEventListener('change', toggleshowprogsLayer)

            function toggleshowprogsLayer() {
                if (showprogsvr.checked) {
                    // Ajouter le layer √† la carte
                    progsvrLayer.addTo(map);
                } else {
                    // Retirer le layer de la carte

                    //progsvrLayer.clearLayers()
                    map.removeLayer(progsvrLayer);
                }
            }


            // Changement sur le showprogsvrjaunes 
            // const showprogsvrjaunes=document.getElementById('showprogsvrjaunes')
            //     showprogsvrjaunes.addEventListener('change', toggleshowprogsLayerJaune)

            //     function toggleshowprogsLayerJaune() {
            //     console.log ('checkbox layer jaune activee')
            //     if (showprogsvrjaunes.checked) { progsvrLayerJaune.addTo(map); } // Ajouter le layer √† la carte   
            //     else                           {  map.removeLayer(progsvrLayerJaune);}// Retirer le layer de la carte
            //     }



            //Changement sur le twsvmg
            var twsvmg = document.getElementById('twsvmg')
            twsvmg.addEventListener("change", function (evt) {
                console.log('Changement detecte sur twsvmg')
                twsvmg = document.getElementById('twsvmg').value
                console.log('changement du vent tws= ' + twsvmg)
                tws10vmg = parseInt(Math.round(twsvmg * 10))
                resvoiles = cherchevoiles(y0vr, x0vr, t0vr, twsvmg, twavr, polar_id)


            });





            // c est le bouton rafraichir pour les progs pas utile avec le websocket

            var rafraichir = document.getElementById('rafraichir')
            rafraichir.addEventListener("click", function (evt) {
                console.log('Bouton de rafraichissement des progs cliqu√©')
                // on appelle la fonction ajax qui recupere le trace des progs
                // il faut avoir user_id et course qui sont des variables globales      
                chercheprogsvr(user_id, course, t0routage)
            });



            // document.getElementById("wptconsole").addEventListener("click", function () {
            //     console.log('waypoints pour test dans console ')

            //     console.log(waypoints)

            // });



            document.getElementById("btnPolaires").addEventListener("click", function () {
                // const urlPolaires = "http://inc.bureauvallee.free.fr/polaires/?race_id=654.1&tws=13.6+&twa=45&utm_source=VRDashboard";
                urlPolaires = `http://blacksailingpolars.vrzen.org/?race_id=${course}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail % 10}`
                const width = 950;
                const height = 850;
                const screenWidth = window.screen.width;
                const left = screenWidth - width - 50; // 50 px du bord droit
                const top = 100; // Position verticale (modifiable)    
                if (popupPolaires && !popupPolaires.closed) {
                    popupPolaires.close();
                    popupPolaires = null;
                } else {
                    popupPolaires = window.open(urlPolaires, "popupPolaires", `width=${width},height=${height},left=${left},top=${top},scrollbars=no,resizable=yes`);
                }



            });



            document.getElementById("btnDivers").addEventListener("click", function () {
                // const urlPolaires = "http://inc.bureauvallee.free.fr/polaires/?race_id=654.1&tws=13.6+&twa=45&utm_source=VRDashboard";
                console.log('polar_id' + polar_id)

                url = `${serveur}/parametres?course=${course}&polar_id=${polar_id}&tws=${twsvr}&twa=${Math.abs(twavr)}&stam=${stamina}&hull=true&winch=true&foil=true&light=true&heavy=true&reach=true&magicFurler=true&comfortLoungePug=true&vrtexJacket=true&voile=${sail % 10}`
                const width = 950;
                const height = 850;
                const screenWidth = window.screen.width;
                const left = screenWidth - width - 50; // 50 px du bord droit
                const top = 100; // Position verticale (modifiable)    

                console.log(url)

                if (popupPara && !popupPara.closed) {
                    popupPara.close();
                    popupPara = null;
                } else {
                    popupPara = window.open(url, "popupParametres", `width=${width},height=${height},left=${left},top=${top},scrollbars=no,resizable=yes`);
                }
            });





            // Fonction pour attacher les √©couteurs de clic sur les lignes de tableau dans la popup
            function attachRowClickListeners(popupWindow) {
                // Recherche des lignes dans le document de la popup
                var rows = popupWindow.document.querySelectorAll(".table4 tr");
                console.log("Rows trouv√©es dans le popup :", rows.length);
                rows.forEach(function (row) {
                    row.addEventListener("click", function () {
                        // Retirer la classe 'selected' de toutes les lignes
                        rows.forEach(function (r) { r.classList.remove("selected"); });
                        // Ajouter la classe 'selected' √† la ligne cliqu√©e
                        this.classList.add("selected");
                    });
                });
            }


            function attachRowClickListeners2(popup) {
                const rows = popup.querySelectorAll(".table4 tr");
                rows.forEach(function (row) {
                    row.addEventListener("click", function () {
                        // Retirer la classe 'selected' de toutes les lignes
                        rows.forEach(r => r.classList.remove("selected"));
                        // Ajouter la classe 'selected' √† la ligne cliqu√©e
                        this.classList.add("selected");
                    });
                });
            }



            // bouton dupliquer dans jaune 
            var dupliquerprogsvr = document.getElementById('dupliquerprogsvr')
            dupliquerprogsvr.addEventListener("click", function (evt) {
                console.log('Bouton de duplication cliqu√©')
                console.log('user_id ' + user_id)
                console.log('course ' + course)
                //programmationsvr=chercheprogsserveur(user_id,course)
                console.log('programmationsvr issues de la demande de duplication')
                console.log(programmationsvr)
                programmationsvrjaunes = [].concat(programmationsvr)
                afficherTableau3(programmationsvr)


            });






            // n existe pas encore 
            // const showprogsvrjaunes=document.getElementById('showprogsvrjaunes')
            // showprogsvrjaunes.addEventListener('change', toggleshowprogsLayerJaune)


            //affichage de la programmation jaune 
            function toggleshowprogsLayerJaune() {
                if (showprogsvrjaunes.checked) {
                    // Ajouter le layer √† la carte
                    progsvrLayerJaune.addTo(map);
                } else {
                    // Retirer le layer de la carte
                    map.removeLayer(progsvrLayerJaune);
                }
            }



            var lancerRoutage = document.getElementById('lancerRoutage')
            lancerRoutage.addEventListener("click", function (evt) {   // on va recuperer les donnees du routage  sur l interface


                console.log('\n Lancement d\'un routage')
                console.log('Ligne 5811 user_id ' + user_id)
                var { lat, lng } = recuperecoordsdep();
                console.log('lat lng' + lat + ' ' + lng)
                //var trajetsencours = JSON.parse(localStorage.getItem("memoiretrajets"))  // on recupere le tableau des waypoints 
                // waypoints = trajetsencours[0][12] est une variable globale  
                console.log('ligne 4363 waypoints ' + waypoints)
                console.log('Tolerance hvmg ' + tolerancehvmg)

                ari = Array.from(idarrivee.selectedOptions).map(option => option.value);
                if (ari == []) { ari = ['Arrivee']; }    //Si on a oubli√© de cocher une case       

                console.log('ligne 4364 ari ' + ari)

                heuredepart = document.getElementById('datetime').value     // on recupere l heure de depart 



                console.log("Valeurs des WP selectionn√©s : ari = ", ari);
                console.log('y0, ' + y0 + ' x0 ' + x0)
                console.log(waypoints)
                console.log('heure de depart  ' + heuredepart)
                var timestamp = new Date(heuredepart).getTime() / 1000; // Convertit en secondes
                var heuredepart = Math.ceil(timestamp / 60) * 60; // Arrondi √† la minute sup√©rieure
                console.log('heure de depart en secondes du routage ' + heuredepart + 'soit ' + hmns.format(heuredepart * 1000))

                t0routage = heuredepart
                // console.log( 'soit ' +hmns.format(heurededepart*1000))

                // on recuperecocheexclusions 
                // let cocheexclusions = document.getElementById('cocheexclusions').checked
                cocheexclusions = 0

                y0 = lat
                x0 = lng
                // on demande le routage
                calculeroutage(lat, lng, heuredepart, waypoints, ari, cocheexclusions)
                // chercheprogsvr(user_id,course,heuredepart+120)
            });



            document.getElementById("detailroute2").addEventListener("click", function () {
                var popupBlocked = false;
                var testPopup = null;

                try {
                    testPopup = window.open("", "_blank", "width=100,height=100");
                    if (!testPopup || testPopup.closed || typeof testPopup.closed === "undefined") {
                        popupBlocked = true;
                    } else {
                        // V√©rifier l'acc√®s au document (bloqueur de popup emp√™che cela)
                        testPopup.document.write("<p>Test</p>");
                        testPopup.document.close();
                    }
                } catch (e) {
                    popupBlocked = true;
                }

                if (testPopup) {
                    testPopup.close();
                }

                if (!popupBlocked) {
                    openPopupWindow();
                } else {
                    openPopupDiv();
                }
            });


            document.getElementById('tolerancehvmg').addEventListener('change', function (e) {
                tolerancehvmg = document.getElementById('tolerancehvmg').value;

                console.log('tolerancehvmg  = ' + tolerancehvmg)
                console.log('username ' + username)
                // on va ajouter tolerancehvmg dans les personalinfos
                typeinfo = 'tolerancehvmg'
                typeaction = 'modify',
                    nom = 'tolerancehvmg'
                valeur = tolerancehvmg

                message = modifpersonalinfos(username, user_id, course, typeinfo, typeaction, nom, valeur)
                console.log(message)

            });





            document.getElementById('gpx-input').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (event) {
                    const gpxText = event.target.result;

                    // Parse XML
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(gpxText, "application/xml");

                    // Convert to GeoJSON
                    const geojson = toGeoJSON.gpx(xml);
                    console.log("GeoJSON extrait :", geojson);


                    const layer = L.geoJSON(geojson, {
                        pointToLayer: function (feature, latlng) {
                            // R√©cup√©ration des donn√©es
                            const coords = latlng;
                            const properties = feature.properties || {};
                            const isoTime = properties.time || '';
                            const timeStr = isoTime
                                ? new Date(isoTime).toLocaleString('fr-FR', {
                                    timeZone: 'Europe/Paris',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    day: '2-digit',
                                    month: '2-digit'
                                })
                                : 'N/A';

                            // Construction du contenu du tooltip
                            const tooltipText = `
            <b> Avalon <b><br>
            <b>Lat:</b> ${coords.lat.toFixed(6)}<br>
            <b>Lon:</b> ${coords.lng.toFixed(6)}<br>
            <b>Heure:</b> ${timeStr}
        `;

                            // Cercle avec tooltip
                            return L.circle(latlng, {
                                radius: 15,
                                color: 'black',
                                fillColor: '#3399ff',
                                fillOpacity: 0.5,
                                weight: 0.5
                            }).bindTooltip(tooltipText, { direction: 'top', permanent: false });
                        }
                    }).addTo(gpx1LayerGroup);



                };
                reader.readAsText(file);
            });





            document.getElementById('gpx-input2').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (event) {
                    const gpxText = event.target.result;

                    // Parse XML
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(gpxText, "application/xml");

                    // Convert to GeoJSON
                    const geojson = toGeoJSON.gpx(xml);
                    console.log("GeoJSON extrait :", geojson);


                    const layer = L.geoJSON(geojson, {
                        pointToLayer: function (feature, latlng) {
                            // R√©cup√©ration des donn√©es
                            const coords = latlng;
                            const properties = feature.properties || {};
                            const isoTime = properties.time || '';
                            const timeStr = isoTime
                                ? new Date(isoTime).toLocaleString('fr-FR', {
                                    timeZone: 'Europe/Paris',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    day: '2-digit',
                                    month: '2-digit'
                                })
                                : 'N/A';

                            // Construction du contenu du tooltip
                            const tooltipText = `
            <b> Avalon <b><br>
            <b>Lat:</b> ${coords.lat.toFixed(6)}<br>
            <b>Lon:</b> ${coords.lng.toFixed(6)}<br>
            <b>Heure:</b> ${timeStr}
        `;

                            // Cercle avec tooltip
                            return L.circle(latlng, {
                                radius: 15,
                                color: 'black',
                                fillColor: '#3399ff',
                                fillOpacity: 0.5,
                                weight: 0.5
                            }).bindTooltip(tooltipText, { direction: 'top', permanent: false });
                        }
                    }).addTo(gpx2LayerGroup);
                };

                gpx2LayerGroup.addTo(map);
                reader.readAsText(file);
            });







            






            function createTexteRoute()

            // dans tabroutage  en   0:niso  1heure     2:lat        3:lon        4:date        5:twa     6:cap   7:vmgmin  8:vmgmax   9:speed  10:voile 11:boost  12:tws 13:twd    14:stamina  15:peno  

            {
                var texteroute;
                urlcss = "{{ url_for('static', filename='css/vrouteur.css') }}"
                let dernier = arrayroutage.length - 1
                //(t0routage + arrayroutage[i][1])
                // console.log (' dernier '+arrayroutage[dernier] )
                texteroute = `<!DOCTYPE html> <h2> ${username} -- ${tabNameCourses[indiceCourse][1]}   --  ${intlhmn.format((t0routage + arrayroutage[0][3]) * 1000)}
                            <span class="purple"> -- ETA : ${intlhmn.format((t0routage + arrayroutage[dernier][1]) * 1000)}</span></h2>
                            <title>D√©tail du routage </title>
                            <link rel="stylesheet" type="text/css" href="${urlcss} ">
                            <table class='table4'>
                            <th  >N </th><th>H +</th><th>Lat</th><th>Lon</th><th>Date </th><th>Twa</th><th>Cap</th>
                            <th>Vmgmin</th><th>Vmgmax</th><th>Speed</th><th>Voile</th><th>Boost</th><th>Tws</th><th>Twd</th><th>Stamina</th><th>Pen.</th>`


                for (var i = 0; i < (arrayroutage.length); i++) {
                    delta = arrayroutage[i][1]
                    // parseInt(arrayroutage[i][3]-arrayroutage[0][3])
                    he = parseInt(delta / 3600)
                    mni = Math.round((delta - 3600 * he) / 60)
                    texteroute += "<tr>"

                    if (i == 0) { texteroute += "<td class='c10' > Pos VR</td>" }
                    else { texteroute += "<td class='c10' >" + i + "</td>" }

                    texteroute += `<td>${he}h ${mni}mn</td>
                                             <td>${arrayroutage[i][2].toFixed(4)}</td>
                                             <td>${arrayroutage[i][3].toFixed(4)}</td>
                                             <td>${intlhmn.format((t0routage + arrayroutage[i][1]) * 1000)}</td>`

                    if (i < ((arrayroutage.length) - 1) & (i > 0))      // twa
                    {
                        if (Math.round(arrayroutage[i][4]) == Math.round(arrayroutage[i + 1][4]) || (Math.round(arrayroutage[i][4]) == Math.round(arrayroutage[i - 1][4]))) { // cas ou les 2 valeurs sont egales 
                            if (arrayroutage[i][5] > 0) { texteroute += "<td class='greenfgrey' id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" } //twa
                            else { texteroute += "<td class='redfgrey'   id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" }
                        }
                        else {  // cas ou les 2 valeurs ne sont pas egales 

                            if (arrayroutage[i][5] > 0) { texteroute += "<td class='green' id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" } //twa
                            else { texteroute += "<td class='red'   id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" }

                        }
                    }
                    else  //cas normal 
                    {
                        if (arrayroutage[i][5] > 0) { texteroute += "<td class='green' id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" } //twa
                        else { texteroute += "<td class='red'   id  ='twa" + i + "' >" + arrayroutage[i][5].toFixed(1) + "</td>" }
                    }



                    if (i < ((arrayroutage.length) - 1) & (i > 0))    //cap
                    {
                        if (Math.round(arrayroutage[i][6]) == Math.round(arrayroutage[i + 1][6]) || (Math.round(arrayroutage[i][6]) == Math.round(arrayroutage[i - 1][6]))) { texteroute += "<td class='bluefgrey'   id  ='cap" + i + "'      >" + arrayroutage[i][6].toFixed(1) + "</td>" }                               //cap
                        else { texteroute += `<td class='blue'   id ='cap${i}'      >${arrayroutage[i][6].toFixed(1)}</td>` }
                    }
                    else { texteroute += `<td class='blue'  id='cap${i}'      >${arrayroutage[i][6].toFixed(1)}</td>` }







                    if (Math.abs(arrayroutage[i][5]) < arrayroutage[i][7]) { color = 'red' } else { color = 'black' }                    //on est inferieur a la twa min 
                    if (Math.ceil(Math.abs(arrayroutage[i][5])) > arrayroutage[i][7]) { color = 'red' } else { color = 'green' }                //on est superieur a la twa max 
                    color = 'black'
                    texteroute += `<td class=${color}>${arrayroutage[i][7].toFixed(1)}</td>             
                                             <td class=${color}>${arrayroutage[i][8].toFixed(1)}</td>
                                             <td >${arrayroutage[i][9].toFixed(2)}</td>`                                             //speed
                    //+"<td >"+ typeVoiles[parseInt(arrayroutage[i][9]%10)]+"</td>"

                    if ((arrayroutage[i][11] > 1) && (arrayroutage[i][11] < 1.0141)) {
                        texteroute += "<td class= 'fondrose'>" + typeVoiles[parseInt(arrayroutage[i][10] % 10)] + "</td>"
                        texteroute += "<td class= 'fondrose'>" + arrayroutage[i][11].toFixed(3) + "</td>"
                    }       //voile
                    else {
                        texteroute += `<td class= 'black'>${typeVoiles[parseInt(arrayroutage[i][10] % 10)]}</td>
                                                           <td               >${arrayroutage[i][11].toFixed(3)}</td>`
                    }                  //rapport

                    texteroute += `<td>${arrayroutage[i][12].toFixed(2)}</td>                                
                                            <td>${arrayroutage[i][13].toFixed(2)}</td>
                                            <td>${arrayroutage[i][14].toFixed(1)}</td>
                                            <td>${arrayroutage[i][15].toFixed(0)}</td>    
                                            </tr>`
                }

                texteroute += `</table></body></html>`
                return texteroute

            }

            //*********************************************************************************************************
            // fonction si popup blockees 
            //*********************************************************************************************************

            function openPopupDiv() {
                texteroute = createTexteRoute()
                const popup = document.createElement("div");
                popup.classList.add("popup");
                // Position verticale par d√©faut
                popup.style.top = "100px";
                popup.style.width = "1000px";
                popup.style.height = "1000px";
                popup.style.overflow = "auto";

                // Cr√©ation de la barre de titre avec la croix de fermeture
                const header = document.createElement("div");
                header.classList.add("popup-header");
                header.textContent = "Detail du routage";

                const close = document.createElement("span");
                close.classList.add("popup-close");
                close.innerHTML = "&times;"; // Affiche le symbole "√ó"
                header.appendChild(close);

                // Cr√©ation du contenu de la popup avec le texte fourni
                const content = document.createElement("div");
                content.classList.add("popup-content");
                content.innerHTML = texteroute;

                // Assemblage de la popup
                popup.appendChild(header);
                popup.appendChild(content);
                document.body.appendChild(popup);

                // Positionner la popup √† 5px du bord droit
                repositionPopup(popup);

                // Fermeture de la popup lors du clic sur la croix
                close.addEventListener("click", function () {
                    popup.remove();
                });

                // Attacher un √©couteur sur les lignes du tableau (si pr√©sent dans le contenu)
                attachRowClickListeners2(popup);

                // Rendre la popup d√©pla√ßable via la barre de titre
                makeDraggable(popup, header);

                // Repositionnement de la popup lors du redimensionnement de la fen√™tre
                function handleResize() {
                    if (document.body.contains(popup)) {
                        repositionPopup(popup);
                    } else {
                        window.removeEventListener("resize", handleResize);
                    }
                }
                window.addEventListener("resize", handleResize);
            }





            function repositionPopup(popup) {
                // Calcul : largeur de la fen√™tre - largeur de la popup - 5px
                const newLeft = window.innerWidth - popup.offsetWidth - 5;
                popup.style.left = newLeft + "px";
            }



            function makeDraggable(popup, handle) {
                let offsetX = 0, offsetY = 0;
                let isDragging = false;

                handle.addEventListener("mousedown", function (e) {
                    isDragging = true;
                    // Calculer le d√©calage entre la position du curseur et le coin sup√©rieur gauche de la popup
                    offsetX = e.clientX - popup.offsetLeft;
                    offsetY = e.clientY - popup.offsetTop;
                    document.addEventListener("mousemove", mouseMove);
                    document.addEventListener("mouseup", mouseUp);
                });

                function mouseMove(e) {
                    if (isDragging) {
                        popup.style.left = (e.clientX - offsetX) + "px";
                        popup.style.top = (e.clientY - offsetY) + "px";
                    }
                }

                function mouseUp() {
                    isDragging = false;
                    document.removeEventListener("mousemove", mouseMove);
                    document.removeEventListener("mouseup", mouseUp);
                }
            }


            //*****************************************************************************************************
            //***********   Variante avec popup *******************************************************************
            //*****************************************************************************************************


            var popup1 = null;

            function openPopupWindow() {
                if (popup1 && !popup1.closed) { popup1.close(); }
                // Ouvrir la nouvelle popup
                popup1 = window.open('', 'route', 'top=10,left=1000,width=1000,height=1000,scrollbars=yes');
                texteroute = createTexteRoute()
                // √âcrire le contenu dans la popup
                popup1.document.write(texteroute);
                popup1.document.close(); // N√©cessaire pour finaliser le chargement du DOM
                // Attendre un court instant pour √™tre s√ªr que le contenu est disponible
                setTimeout(function () { attachRowClickListeners(popup1); }, 500);
                // Fermer la popup automatiquement apr√®s 600000 ms (10 minutes)
                setInterval(function () { fermeturepopup(popup1); }, 600000);
            }


            // Fonction de fermeture de la popup
            function fermeturepopup(fenetre) {
                if (fenetre && !fenetre.closed) {
                    fenetre.close();
                }
                // Par exemple, on r√©initialise le contenu du bouton et la progress bar
                document.getElementById('detailroute2').innerHTML = "Afficher D√©tail Route";
                var prog = document.getElementById('progress');
                if (prog) prog.value = 0;
            }




            //*****************************************************************************************************
            //***********   Fin Variante avec popup *******************************************************************
            //*****************************************************************************************************




            window.centrage = () => {
                try {
                    map.panTo([y0vr, x0vr])
                }
                catch { console.log('Centrage pas possible') }
            }


            window.copyLatLonToClipboard = async (lat, lon) => {
                try {

                    var position = toDMSString(lat, lon)
                    await navigator.clipboard.writeText(position);
                    console.log("Coordonn√©es copi√©es :", position);
                }
                catch (err) {
                    console.error("Erreur de copie dans le presse-papier :", err);
                }
            };



            window.cartelocale = async (lat, lng) => {
                try {
                    carte = await chargecartemaps2(lat, lng);
                    Lcarte2 = L.polyline(carte).setStyle({ color: 'purple', weight: 1, opacity: 1, }).addTo(map)   // on peut laisser la carte meme si on change de course
                    // affichecarte(carte);
                } catch (error) {
                    console.log('R√©cup√©ration pas possible', error);
                }
            };

            var pointIcon = L.divIcon({
                className: "custom-point",
                html: '<div style="width:4px;height:4px; background:black;border-radius:50%;"></div>',
                iconSize: [2, 2]
            });


            window.grilleWpt = async (lat, lng) => {
                try {
                    var minLat = Math.abs(lat < 10 ? 5 : 5)
                    var minLng = 5;
                    var lat0 = Number(lat.toFixed(minLat))
                    var lng0 = Number(lng.toFixed(minLng))
                    var pasLat = Number(Math.pow(10, -1 * minLat).toFixed(minLat))
                    var pasLng = Number(Math.pow(10, -1 * minLng).toFixed(minLng))

                    console.log ('pasLat '+ pasLat)
                    console.log ('pasLng' + pasLng)

                    for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 10; j++) {

                            let lat = lat0 + (i - 5) * pasLat;
                            let lng = lng0 + (j - 5) * pasLng;

                            L.marker([lat, lng], { icon: pointIcon }).addTo(grilleLayer);

                        }

                        grilleLayer.addTo(map)

                    }





                    console.log(lat, lng)
                } catch (error) {
                    console.log('R√©cup√©ration pas possible', error);
                }
            };




            // // √âcouteur pour l'√©v√©nement "paste" sur input Coordinates
            document.getElementById("inputCoordinates").addEventListener("paste", (event) => {
                // Emp√™cher le comportement par d√©faut si n√©cessaire
                event.preventDefault();
                const clipboardData = event.clipboardData || window.clipboardData;  // R√©cup√©rer le texte coll√©
                const pastedData = clipboardData.getData("text");
                event.target.value = pastedData;             // Ins√©rer le texte coll√© dans le champ

                // Conversion des coordonn√©es en d√©cimales
                const { latDecimal, lngDecimal } = dmsToDecimal(pastedData);
                affichecoordsdep(latDecimal, lngDecimal)

            });



document.getElementById('csv-input3').addEventListener('change', function (event) {
    console.log ('chargement csv lanc√©')
    const file = event.target.files[0];
    if (!file) return;

    Papa.parse(file, {
        header: true,
        delimiter: ";",
        complete: function (results) {
            csvLayerGroup.clearLayers(); // supprime les anciens points CSV
            const coords = [];

            results.data.forEach(row => {
                if (!row.position) return;

                const [lat, lon] = dmsToDecimal2(row.position);
                if (isNaN(lat) || isNaN(lon)) return;

                coords.push([lat, lon]);

                const popup = `
                    <b>${row.time || ''}</b><br>
                    SOG: ${row.sog || ''} kn<br>
                    COG: ${row.cog || ''}¬∞<br>
                    TWS: ${row.TWS || ''} kn<br>
                    TWD: ${row.TWD || ''}¬∞
                `;

                L.circleMarker([lat, lon], {
                    radius: 0.5,
                    color: 'blue',
                    fillColor: 'cyan',
                    fillOpacity: 0.6
                })
                .bindPopup(popup)
                .addTo(csvLayerGroup);
            });

            console.log('coords '+coords)
            csvLayerGroup.addTo(map)
            if (coords.length > 1) {
                L.polyline(coords, { color: 'red', weight: 1 }).addTo(csvLayerGroup);
                map.fitBounds(coords);
            }


        }
    });
});



document.getElementById('showgpx1').addEventListener('change', function(e) {
    if (e.target.checked) {
        map.addLayer(gpx1LayerGroup);
    } else {
        map.removeLayer(gpx1LayerGroup);
    }
});

document.getElementById('showgpx2').addEventListener('change', function(e) {
    if (e.target.checked) {
        map.addLayer(gpx2LayerGroup);
    } else {
        map.removeLayer(gpx2LayerGroup);
    }
});

document.getElementById('showcsv').addEventListener('change', function(e) {
    console.log ('showcsv actionn√©')
    if (e.target.checked) {
        map.addLayer(csvLayerGroup);
    } else {
        map.removeLayer(csvLayerGroup);
    }
});







            //************************************************************************************************
            //***********    Gestionnaires de map  leaflet  **************************************************
            //************************************************************************************************


            map.on('contextmenu', function (e) {
                let lat = e.latlng.lat;
                let lng = e.latlng.lng;

                console.log('username' + username + ' course' + course + 'lat' + e.latlng.lat)

                popup.setLatLng(e.latlng, map)
                    .setContent
                    ("  <b>   Latitude &nbsp; &nbsp;: " + pos_dec_mn(e.latlng.lat) + " (" + arrondi(e.latlng.lat, 4) + ") "
                        + " <br> Longitude : " + pos_dec_mn(e.latlng.lng) + " (" + arrondi(e.latlng.lng, 4) + ")"


                        // + `<br><a href="javascript:void(0);"  onclick= "cartelocaleOld(${lat},${lng}) ";> Carte locale</a>`
                        + `<br><a href="javascript:void(0);"  onclick= "cartelocale(${lat},${lng}) ";> Carte locale 10¬∞x10¬∞</a>`

                        + `<br><a href="javascript:void(0);"  onclick= "grilleWpt(${lat},${lng}) ";> Grille Wpt</a>`
                        + "<br><a href=javascript:void(0); onclick= 'centrage() ';> Centrage sur Bateau</a>"

                        // + `<br><a href="javascript:void(0);"  onclick= "ajoutewaypoint3(${lat},${lng}) ";> Ajouter un waypoint</a>`
                        //     //+'<br> {"lat":'+arrondi(e.latlng.lat,4)+',"lon":'+arrondi(e.latlng.lng,4)+'},'
                        //     +"<br><a href=javascript:void(0); onclick= 'Routagejsdepart("+e.latlng.lat+","+e.latlng.lng+") ';> Definir comme Depart</a>"

                        //     +"<br><a href=javascript:void(0); onclick= 'Routagejsarrivee("+e.latlng.lat+","+e.latlng.lng+") ';> Definir comme Arrivee</a>"
                        //    // +"<br><a href=javascript:void(0); onclick= 'Routagejsarrivee("+e.latlng.lat+","+e.latlng.lng+") ';> Definir comme Arrivee</a>"

                        // +"<br><a href=javascript:void(0); onclick= 'stockepoint("+e.latlng.lat+","+e.latlng.lng+") ';> Ajouter une Zone d'exclusions </a>"
                    )

                    .openOn(map);
                PopupOpen = true;
            });



            map.on('mousemove', function (e) {


                document.getElementById('latitudevent').innerHTML = pos_dec_mn_lat(e.latlng.lat) + ' (' + e.latlng.lat.toFixed(4) + ')'
                document.getElementById('longitudevent').innerHTML = pos_dec_mn_lng(e.latlng.lng) + ' (' + e.latlng.lng.toFixed(4) + ')'
                distcapcurseur = dist_cap_ortho2(y0vr, x0vr, e.latlng.lat, e.latlng.lng)              // distance et cap vers le curseur       
                twac = ftwao(distcapcurseur[1], twdvr)                                              // twa pour le premier troncon vers le curseur 
                document.getElementById('hdg').innerHTML = distcapcurseur[1].toFixed(0)
                document.getElementById('twa').innerHTML = twac.toFixed(0)



                /* try {
                        var decalage= document.getElementById('mnDecalageMeteo').value  
                        var tempsdecale=tempscourant+decalage*3600*1000 // temps pour affichage meteo avec decalage 
                        meteocurseur=vit_angle_vent (e.latlng.lat,e.latlng.lng ,tempsdecale/1000)
                        twscurseur                                      = meteocurseur[0].toFixed(2)
                        twdcurseur                                      = meteocurseur[1].toFixed(2)            
                        document.getElementById('twscurseur').innerHTML = twscurseur
                        document.getElementById('twdcurseur').innerHTML = twdcurseur    
                        
         
                       
         
             //    //        console.log ('Meteo depart  tws '+twsvr+ ' twd '+twdvr +' twavr '+twavr )
                        
             //            cap0=distcapcurseur[1]
             //            //t0simul=t0start.getTime()
             //            t0simul=t0vr*1000   // pour que les courvbes soient en phase
         
             //         //    console.log ('ligne 1228 y0vr '+y0vr)
             //         //    console.log ('ligne 1228 x0vr '+x0vr)
             //         //    console.log ('ligne 1228 cap0 '+cap0)
             //         //    console.log ('ligne 1228 twavr'+twavr)
             //         //    console.log ('ligne 1228  sail '+sail)
             //         //    console.log ('ligne 1228 stamina '+stamina)
             //         //    console.log ('ligne 1228 tempsdepartsimul en ms '+t0simul + ' soit ' +intlhmn.format(t0simul))   //  la simulation se fait a partir du temps de depart du routage
                        
                        
             //         if (cap0!=valinit)     // calcul des lignes rouge cap  et verte twa s il y a changement de cap
             //           {   
             //             valinit=cap0
             //             for ( var j=1 ; j<74 ; j++ )  {map.removeLayer(circle1[j]);  map.removeLayer(circle2[j])    }  // on efface les anciens points 
             //             map.removeLayer(polycap1)
         
             //         if (affichecapval==1)
             //             {    
         
             //            // for ( var j=1 ; j<74 ; j++ )  {map.removeLayer(circle1[j]);  map.removeLayer(circle2[j])    }  // on efface les anciens points 
             //                 nb=72
         
             //                 tabpolycapvoile= polycap(y0routage,x0routage,t0simul/1000,cap0,twavr,sail,stamina,nb,polairesglobales,carabateau)
                         
                         
             //             //    console.log (tabpolycapvoile);
             //             //   var ligne=  L.polyline( tabpolycapvoile).setStyle({ color: 'blue', weight:1, opacity:1, }).addTo(map);
             //                 // ligne =new Array
             //                 // ligne[0]=[y0routage,x0routage]
             //                 for ( var i=1 ; i<tabpolycapvoile.length ; i++ )                // on affiche les nouveaux 
             //                     {
             //                         if (i%6 != 0) 
             //                         {circle1[i] = L.circle([tabpolycapvoile[i][0],tabpolycapvoile[i][1]] ,{fillColor: colors[tabpolycapvoile[i][2]] ,color: [tabpolycapvoile[i][2]], weight:1 ,opacity:1,fillOpacity: 1,radius: 150,}).addTo(map)}
             //                         else
             //                         { circle1[i] = L.circle([tabpolycapvoile[i][0],tabpolycapvoile[i][1]] ,{fillColor: colors[tabpolycapvoile[i][2]] ,color: [tabpolycapvoile[i][2]], weight:1 ,opacity:1,fillOpacity: 1,radius: 220,}).addTo(map)  }                                                                
             //                    //ligne[i]=([tabpolycapvoile[i][0],tabpolycapvoile[i][1]])
             //                     }
         
             //             //         console.log ('en 2460')
             //             //         console.log(ligne)
             //             //    var polycap1 =     L.polyline( ligne).setStyle({ color: 'blue', weight:1, opacity:1, }).addTo(map);
         
             //             }
         
         
             //          if (affichetwaval==1){
             //                // for ( var j=1 ; j<74 ; j++ )  {map.removeLayer(circle1[j]);  map.removeLayer(circle2[j])    }  // on efface les anciens points 
             //                 twa0=-Math.round(twac)   
             //                 tabpolytwavoile= polytwa(y0routage,x0routage,t0simul/1000,  twa0 ,twavr,sail,stamina,nb,polairesglobales,carabateau)  
                
                         
             //                 for ( var i=1 ; i<tabpolytwavoile.length ; i++ )                // on affiche les nouveaux       
             //                     {
             //                     if (i%6 != 0) 
             //                     {   circle2[i] = L.circle([tabpolytwavoile[i][0],tabpolytwavoile[i][1]] ,{fillColor: colors[tabpolytwavoile[i][2]] ,color: 'black', weight:1,opacity:1,fillOpacity: 1,radius: 150,}).addTo(map)     }
             //                 else{
             //                         circle2[i] = L.circle([tabpolytwavoile[i][0],tabpolytwavoile[i][1]] ,{fillColor: colors[tabpolytwavoile[i][2]] ,color: 'red', weight:1,opacity:1,fillOpacity: 1,radius: 220,}).addTo(map) 
             //                     }
             //                     }
             //                 }
             //             }
                     
         
                     }
                             catch {console.log('Les vents ne sont pas encore disponibles')}*/
            });


            //************************************************************************************************
            //***********    Gestionnaires de map  windy    **************************************************
            //************************************************************************************************



            broadcast.on('redrawFinished', () => {
                map.removeLayer(circlew) // on retire l ancie point        

                try {        //  ne fonctionne que s'il y a eu un routage

                    let sec = parseInt((store.get('timestamp')) / 1000);
                    let npoint = recherche(sec, tc) - 1;
                    npoint += 3
                    console.log(' point   ' + arrayroutage[npoint][1] + ' ' + arrayroutage[npoint][2] + ' ' + arrayroutage[npoint][3])
                    circlew = L.circle([arrayroutage[npoint][2], arrayroutage[npoint][3]], { color: 'red', fillColor: 'white', opacity: 1, fillOpacity: 0.5, radius: 3000 }).addTo(map);
                }
                catch {
                    console.log(' ')
                }

            });



function afficheBoatInfosElse(posStart){

console.log ('posStart de else '+posStart)
  username2 = posStart.username
                  race = posStart.race
                  leg = posStart.leg
                  course = race + '.' + leg
                  y0else = posStart['lat']               // Derni√®re position VR 
                  x0else = posStart['lon']
                  lastCalcDate     = posStart['lastCalcDate']      // dernier temps de calcul en s   
                  twselse = posStart['tws'] 
                  twdelse = posStart['twd'] 
                  twaelse = posStart['twa'] 
                  headingelse = posStart['heading'] 
                  speedelse   = posStart['speed']
                  sailelse    = posStart['sail']

affichecoordsdep(y0else, x0else)                   // Les coordonnnees du depart sont celle de boatinfos  dans tous les cas


                // Remplissage de la boite 2 avec les donnees VR
                document.getElementById('dateposvr').innerHTML = intlhmn.format(lastCalcDate)
                document.getElementById('usernamevr').innerHTML = username2
                document.getElementById('y0vr').innerHTML = pos_dec_mn_lat(y0else) + '(' + y0else.toFixed(4) + ") "
                document.getElementById('x0vr').innerHTML = pos_dec_mn_lng(x0else) + '(' + x0else.toFixed(4) + ") "
                document.getElementById('twsvr').innerHTML = twselse.toFixed(2)
                document.getElementById('twdvr').innerHTML = twdelse.toFixed(2)
                document.getElementById('twavr').innerHTML = twaelse.toFixed(2)
                document.getElementById('speedvr').innerHTML = speedelse.toFixed(2)
                document.getElementById('sailvr').innerHTML = typeVoiles[(sailelse % 10) ]
                document.getElementById('headingvr').innerHTML = headingelse.toFixed(2)


}





async function mainelse() {

    console.log ('routage d un autre bateau ')

            console.log ('posStart '+JSON.stringify(posStart))
                  username2 = posStart.username
                  race = posStart.race
                  leg = posStart.leg
                  course = race + '.' + leg
                  y0else = posStart['lat']               // Derni√®re position VR 
                  x0else = posStart['lon']
                  lastCalcDate     = posStart['lastCalcDate']      // dernier temps de calcul en s   
                  twselse = posStart['tws'] 
                  twdelse = posStart['twd'] 
                  twaelse = posStart['twa'] 
                  headingelse = posStart['heading'] 
                  speedelse   = posStart['speed']
                  sailelse    = posStart['sail']
                  


            document.getElementById('idusername').value = username2
            console.log ('username  '+username)
            console.log(username2,course,y0else, x0else, lastCalcDate, twselse, twdelse, twaelse,headingelse, speedelse,sailelse)
                    // afficheBoat(y0vr, x0vr, t0, twsvr, twdvr, heading, username)
            afficheBoat2(y0else, x0else, t0, twselse, twdelse, headingelse, twaelse, speedelse, sailelse, username2, 'red')
            //On va remplir les coordonnees de depart 

            trajet = trouvederniertrajet()
            console.log(trajet) 
            console.log('trajet') 
// on va afficher le parcours et les waypoints 
            map.panTo([y0vr, x0vr])               // on centre la carte normalement on a les coordonnees par trouvederniertrajet                             

            leginfos = await chercheleginfos(course)
            afficheleginfos(leginfos)
            console.log(`leginfos recuperees pour la course par chercheleginfos ${course} \n*******************\n ${leginfos}`)

            carte = await chargecartemaps2(y0else, x0else)
            affichecarte(carte)                                       // affiche la carte locale pas forcement necessaire 

            chercheTeamNames('BSP')


            // on va chercher dans memoire trajets ari et waypoints pour la course , normlement , c'est le dernier trajet 

            trajet=trouvederniertrajetcourse( course)
            username=trajet[0]                           // c est le nom

            console.log ('dernier trajet sur course')
            console.log (trajet)

            // on va afficher les coordonnees depart et arrivee

             // on affiche le selectcourse   
                let tabValeurs = tabNameCourses.map(subArray => subArray[0]);
                let tabNoms = tabNameCourses.map(subArray => subArray[1]);
                let coursesUser = await cherchecoursesuser(username) // on cherche les courses en cours du username

                // on reaffiche les courses dans le tab  
                console.log('coursesUser issues du serveur :')
                console.log(coursesUser)

                if (coursesUser == null)   //si l utilisateur est Bateau Inconnu on lui a attribu√© une course d'office 
                { // on est dans le cas d'un nouveau bateau ou de bateau inconnu qui n a pas encore de courses repertori√©es 
                    course = tabNameCourses[0][0];
                    coursesUser = [course]
                }
                var selectcourse = generateSelect('idcourse', tabValeurs, tabNoms, coursesUser, course, 'limited-width-select-200')
                document.getElementById('idselectcourse').innerHTML = selectcourse



                //****************************************************************************
                // ********** On recherche les personalinfos du userprincipal
                //****************************************************************************
                console.log(`Recherche de PersonalInfos  pour ${username}  ${user_id} sur  course ${course}`)
                personalInfosStr = await recherchepersonalinfos(username, user_id, course)
                personalInfosJS = JSON.parse(personalInfosStr);

                console.log('personalinfos  issues du serveur ' + personalInfosStr)

                affichewaypoints2(personalInfosJS)
                afficheZonesExclusions(personalInfosJS)
                afficheBarrieres(personalInfosJS)
                recupereRoutes(personalInfosJS)

                waypoints = Object.values(personalInfosJS.wp).sort((a, b) => a[0] - b[0]);
                nomsWaypoints = waypoints.map(item => item[1]);
                // ari=personalInfosJS['ari']                         // Pour l instant on va utiliser ari de memoiretrajets et non celui de personalinfos 

                // console.log('ligne 3971 waypoints ' + waypoints + ' ari ' + ari)
                afficheselectarrivee(waypoints, ari)// on affiche le select arrivee avec les waypoints et ceux selectionnes  contenus dans 
                

                  if (typeof ari === "undefined") {
                    ari = ['Arrivee'];
                }


                // ici on peut afficher les coordonnees du dernier wp selectionn√© qui est le dernier element de ari 
                nomdernierwp = ari[ari.length - 1]                                        // nom du dernier wp
                waypoint = waypoints.find(waypoints => waypoints[1] === nomdernierwp) // on le recherche dans la liste 
                try {
                    y1 = waypoint[2]
                    x1 = waypoint[3]
                }
                catch { y1 = 47; x1 = -3; nomdernierwp = 'test' }

                document.getElementById('iddernierwp').innerHTML = nomdernierwp
                affichecoordsari(y1, x1)

                // pour pouvoir numeroter les waypoints 
                nbWP = personalInfosJS.wp ? Object.keys(personalInfosJS.wp).length : 0;
                console.log('nbWP : ' + nbWP)



                //****************************************************************************
                //****************************************************************************

                // on affiche le select depart 
                tabNoms = ['Position VR - Heure VR ', 'Coordonn√©es / Heure Manuelle ', 'Coordonn√©es / Heure Depart ']
                tabValeurs = [0, 1, 2]
                grises = []
                selectini=0
                selectdepart = generateSelect('iddepart', tabValeurs, tabNoms, grises, selectini, 'limited-width-select-100')
                document.getElementById('idselectdepart').innerHTML = selectdepart


               afficheBoatInfosElse(posStart)





}





            //************************************************************************************************
            //***********    Lancement et mises a jour  ******************************************************
            //************************************************************************************************
            //initialise le local storage, si c'est la premiere connexion 
            initialise1()    // initialise si rien dans localstorage et charge la liste des courses 

            if (isMe=='yes')    { main() }

            else { mainelse()




            }
          




         
            //setInterval(function(){  update(username,course,bloque)        ;}, 20000);      // update2 toutes les 20s sauf si bloque=1

            setInterval(function () {
                let nowMSec = nowJS.getTime()
                ecartTemps = (nowMSec - lastCalcDate) / 1000;
                console.log('ecartTemps' + ecartTemps);
                verifierDeltat(ecartTemps);
            }, 60000);      //         toutes les 60s




        })//fin de windyinit


        //************************************************************************************************
        //***********    Fin du script       ******************************************************
        //************************************************************************************************


    </script>
</head>

<body>
    <div id="windy"></div>
</body>

</html>